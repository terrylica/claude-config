# Option 1b vs 1c Complexity Analysis

## TL;DR Recommendation

**Use Option 1b** - The complexity jump from 1b → 1c is significant with minimal security gain for your use case.

- **Option 1b effort**: ~30 minutes (one-time setup)
- **Option 1c effort**: ~3-4 hours (initial) + ongoing maintenance overhead
- **Security benefit**: Negligible (both use SSH, keys already passphrase-protected)

---

## Option 1b: SSH + Doppler Shared Keys (RECOMMENDED)

### Implementation Steps

1. **Store SSH keys in Doppler** (5 minutes)
```bash
# Store each SSH private key
doppler secrets set SSH_KEY_TAINORA --project claude-config --config dev < ~/.ssh/id_ed25519_tainora
doppler secrets set SSH_KEY_TERRYLICA --project claude-config --config dev < ~/.ssh/id_ed25519_terrylica
doppler secrets set SSH_KEY_459ECS --project claude-config --config dev < ~/.ssh/id_ed25519_459ecs
```

2. **Create sync script** (10 minutes) - `~/.local/bin/sync-ssh-keys`
```bash
#!/bin/bash
# Sync SSH keys from Doppler to local machine

set -euo pipefail

KEY_DIR="$HOME/.ssh"
PROJECT="claude-config"
CONFIG="dev"

# Fetch and write keys with correct permissions
doppler secrets get SSH_KEY_TAINORA --project "$PROJECT" --config "$CONFIG" --plain > "$KEY_DIR/id_ed25519_tainora"
doppler secrets get SSH_KEY_TERRYLICA --project "$PROJECT" --config "$CONFIG" --plain > "$KEY_DIR/id_ed25519_terrylica"
doppler secrets get SSH_KEY_459ECS --project "$PROJECT" --config "$CONFIG" --plain > "$KEY_DIR/id_ed25519_459ecs"

# Fix permissions (SSH requires 600)
chmod 600 "$KEY_DIR"/id_ed25519_*

echo "✅ SSH keys synced from Doppler"
```

3. **Make executable** (1 minute)
```bash
chmod +x ~/.local/bin/sync-ssh-keys
```

4. **Run on new machine** (1 minute)
```bash
sync-ssh-keys
```

### Total Implementation
- **Files created**: 1 (sync script)
- **Lines of code**: ~20 lines
- **Setup time**: 15 minutes
- **Per-machine setup**: 1 minute (run sync script)
- **Maintenance**: None (keys synced once per machine)

### Your Existing SSH Config (NO CHANGES NEEDED)
```ssh
# Tainora: any cwd with "/scripts"
Match host github.com exec "echo $PWD | grep -q '/scripts'"
    IdentityFile ~/.ssh/id_ed25519_tainora

# 459ecs: any cwd with "/459ecs"
Match host github.com exec "echo $PWD | grep -q '/459ecs'"
    IdentityFile ~/.ssh/id_ed25519_459ecs

# Eon-Labs: match any cwd containing "/eon/" OR "ml-"
Match host github.com exec "echo $PWD | grep -q -E '(/eon/|ml-)'"
    IdentityFile ~/.ssh/id_ed25519_eonlabs
```

**Git operations work transparently** - no wrapper scripts needed.

---

## Option 1c: SSH + Doppler Ephemeral Mounting

### Implementation Challenges

#### Challenge 1: Git Cannot Use Process Substitution Directly
Git doesn't support `-i <(doppler secrets get ...)` because:
- Git calls SSH internally
- SSH config `IdentityFile` expects real file paths, not named pipes
- Process substitution creates `/dev/fd/63` which SSH rejects

**Example of what DOESN'T work:**
```bash
# ❌ This fails - Git can't pass process substitution to SSH
GIT_SSH_COMMAND="ssh -i <(doppler secrets get SSH_KEY --plain)" git clone git@github.com:user/repo.git
```

#### Challenge 2: SSH Config Integration
Your existing SSH Match directives use static file paths:
```ssh
IdentityFile ~/.ssh/id_ed25519_tainora
```

To use ephemeral mounting, you'd need to:
1. Create wrapper scripts for each key
2. Modify SSH config to use `ProxyCommand` or environment variable injection
3. Handle SSH's multi-read requirements (keys read 2-3 times during handshake)

### Implementation Steps

1. **Store keys in Doppler** (same as 1b - 5 minutes)

2. **Create wrapper script per account** (45 minutes) - 3 scripts needed

`~/.local/bin/git-with-tainora-key`:
```bash
#!/bin/bash
set -euo pipefail

# Create temporary directory for ephemeral key
TMP_DIR=$(mktemp -d)
trap "rm -rf $TMP_DIR" EXIT

KEY_FILE="$TMP_DIR/id_ed25519_tainora"

# Fetch key from Doppler
doppler secrets get SSH_KEY_TAINORA \
  --project claude-config \
  --config dev \
  --plain > "$KEY_FILE"

chmod 600 "$KEY_FILE"

# Run git with this key
GIT_SSH_COMMAND="ssh -i $KEY_FILE -o IdentitiesOnly=yes" git "$@"
```

Similar scripts needed for: `git-with-terrylica-key`, `git-with-459ecs-key`

3. **Create directory detection wrapper** (60 minutes) - `~/.local/bin/git-auto`
```bash
#!/bin/bash
set -euo pipefail

# Detect which key to use based on current directory
CWD="$PWD"

if echo "$CWD" | grep -q '/scripts'; then
    exec git-with-tainora-key "$@"
elif echo "$CWD" | grep -q '/459ecs'; then
    exec git-with-459ecs-key "$@"
elif echo "$CWD" | grep -q -E '(/eon/|ml-)'; then
    exec git-with-terrylica-key "$@"
else
    echo "❌ Error: Could not determine GitHub account from directory: $CWD"
    exit 1
fi
```

4. **Create shell alias** (5 minutes) - Add to `~/.zshrc`
```bash
alias git='git-auto'
```

5. **Handle edge cases** (60 minutes)
- SSH agent conflicts (need `IdentitiesOnly=yes`)
- Multi-machine Doppler token distribution
- Fallback when Doppler unavailable
- Performance overhead (key fetch on every git command)

6. **Update SSH config** (30 minutes)
Problem: Your existing SSH Match directives will still try to use local keys. You need to either:
- Remove Match directives (breaks non-git SSH)
- Add `IdentitiesOnly=yes` to prevent fallback
- Create dual configs for git vs non-git SSH

### Total Implementation
- **Files created**: 5 (3 wrapper scripts + 1 auto-detector + 1 shell alias)
- **Lines of code**: ~150 lines
- **Setup time**: 3-4 hours initial implementation
- **Per-machine setup**: 5-10 minutes (install wrappers + configure)
- **Maintenance**: High (debugging, edge cases, performance tuning)

### Performance Impact
Every git operation incurs:
- Doppler API call (~200-500ms)
- Temporary file creation/deletion
- Extra shell invocations

For rapid git workflows (rebase, multiple commits), this adds up.

---

## Security Comparison

| Aspect | Option 1b | Option 1c |
|--------|-----------|-----------|
| **Keys on disk** | Yes (synced once) | No (ephemeral) |
| **Passphrase protection** | Yes | Yes |
| **File permissions** | 600 (SSH enforced) | 600 (script enforced) |
| **Key exposure window** | Permanent on machine | Seconds per operation |
| **Risk if machine compromised** | Attacker gets keys | Attacker gets keys from Doppler token |
| **Doppler token exposure** | Required once per machine | Required every git operation |

**Critical insight**: Option 1c doesn't eliminate key exposure - it just shifts it:
- 1b: Keys stored locally (with passphrase)
- 1c: Doppler token stored locally (API access to keys)

If an attacker compromises your machine, they get either:
- **Option 1b**: Encrypted SSH keys (need passphrase)
- **Option 1c**: Doppler token (full API access to ALL secrets, not just SSH keys)

**Option 1c is arguably LESS secure** because Doppler token compromise exposes more than just SSH keys.

---

## Complexity Scorecard

| Factor | Option 1b | Option 1c |
|--------|-----------|-----------|
| Lines of code | 20 | 150+ |
| Files created | 1 | 5+ |
| Setup time | 15 min | 3-4 hours |
| Per-machine setup | 1 min | 5-10 min |
| Maintenance overhead | None | High |
| Git workflow impact | Zero | Every operation |
| Debugging complexity | Low | High |
| SSH config changes | None | Significant |
| Performance overhead | Zero | 200-500ms per git op |
| Edge cases | Few | Many |

---

## Recommendation: Use Option 1b

### Why 1b Wins

1. **KISS Principle**: 20 lines vs 150+ lines
2. **DRY Principle**: Single sync script vs duplicated wrappers
3. **Zero workflow friction**: Git works normally
4. **Security equivalence**: Both rely on stored credentials (keys vs token)
5. **Maintenance**: Set-and-forget vs ongoing debugging
6. **Performance**: Zero overhead vs API latency

### When Option 1c Makes Sense

Option 1c is valuable when:
- You're in a **shared/untrusted environment** (CI/CD runners)
- Keys need **sub-minute rotation** (high-security orgs)
- Compliance requires **zero persistent secrets** on disk
- You're willing to trade **developer velocity for audit trails**

For your use case (personal machines, multiple GitHub accounts), these don't apply.

### Implementation Plan for 1b

```bash
# 1. Store keys in Doppler (one-time)
doppler secrets set SSH_KEY_TAINORA --project claude-config --config dev < ~/.ssh/id_ed25519_tainora
doppler secrets set SSH_KEY_TERRYLICA --project claude-config --config dev < ~/.ssh/id_ed25519_terrylica
doppler secrets set SSH_KEY_459ECS --project claude-config --config dev < ~/.ssh/id_ed25519_459ecs

# 2. Create sync script
cat > ~/.local/bin/sync-ssh-keys << 'EOF'
#!/bin/bash
set -euo pipefail
KEY_DIR="$HOME/.ssh"
doppler secrets get SSH_KEY_TAINORA --project claude-config --config dev --plain > "$KEY_DIR/id_ed25519_tainora"
doppler secrets get SSH_KEY_TERRYLICA --project claude-config --config dev --plain > "$KEY_DIR/id_ed25519_terrylica"
doppler secrets get SSH_KEY_459ECS --project claude-config --config dev --plain > "$KEY_DIR/id_ed25519_459ecs"
chmod 600 "$KEY_DIR"/id_ed25519_*
echo "✅ SSH keys synced from Doppler"
EOF

# 3. Make executable
chmod +x ~/.local/bin/sync-ssh-keys

# 4. Test sync
sync-ssh-keys

# 5. On new machines: just run sync-ssh-keys
```

**Your existing SSH config continues to work unchanged.**

---

## Effort Estimate Summary

| Task | Option 1b | Option 1c |
|------|-----------|-----------|
| Research & design | 30 min | 2 hours |
| Implementation | 15 min | 3-4 hours |
| Testing | 5 min | 1 hour |
| Documentation | 10 min | 30 min |
| **Total initial** | **1 hour** | **6-7 hours** |
| Per-machine setup | 1 min | 10 min |
| Annual maintenance | 0 hours | 2-4 hours |

**ROI Analysis**: You'd need to value ephemeral mounting at 6+ hours of additional effort for marginal security gain.
