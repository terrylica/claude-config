"""
Deep dive analysis: Why are 6 cross-interval features constant?

This script investigates the design rationale and triggering conditions
for the 6 features that remain constant (always 0) in typical datasets.
"""
import numpy as np
import pandas as pd
import sys
sys.path.insert(0, '/Users/terryli/eon/atr-adaptive-laguerre/src')

from atr_adaptive_laguerre.features.atr_adaptive_rsi import (
    ATRAdaptiveLaguerreRSI,
    ATRAdaptiveLaguerreRSIConfig,
)

# Generate test data (1000 bars)
np.random.seed(42)
n_bars = 1000
dates = pd.date_range("2024-01-01", periods=n_bars, freq="2h")

# Random walk price with realistic volatility
price = 100 + np.cumsum(np.random.randn(n_bars) * 2)
data = pd.DataFrame({
    "date": dates,
    "open": price,
    "high": price + np.random.rand(n_bars) * 2,
    "low": price - np.random.rand(n_bars) * 2,
    "close": price + np.random.randn(n_bars) * 0.5,
    "volume": np.random.randint(1000000, 10000000, n_bars),
})

print("="*80)
print("CONSTANT FEATURE ANALYSIS")
print("="*80)

# Test without filtering to get all 121 features
config = ATRAdaptiveLaguerreRSIConfig.multi_interval(
    multiplier_1=4,
    multiplier_2=12,
    filter_redundancy=False,
)
indicator = ATRAdaptiveLaguerreRSI(config)
features = indicator.fit_transform_features(data)

print(f"\nGenerated {features.shape[1]} features from {features.shape[0]} bars")

# Analyze the 6 constant features
constant_features = [
    'all_intervals_bearish',
    'all_intervals_crossed_overbought',
    'all_intervals_crossed_oversold',
    'all_intervals_neutral',
    'cascade_crossing_up',
    'gradient_up',
]

print("\n" + "="*80)
print("FEATURE-BY-FEATURE ANALYSIS")
print("="*80)

# First, examine the underlying regime and crossing data
print("\n### REGIME DISTRIBUTION ###")
for interval in ['base', 'mult1', 'mult2']:
    regime_col = f'regime_{interval}' if interval != 'base' else 'regime_base'
    if regime_col in features.columns:
        regime_counts = features[regime_col].value_counts().sort_index()
        print(f"\n{interval} regime distribution:")
        for regime, count in regime_counts.items():
            pct = 100 * count / len(features)
            regime_name = {0: 'bearish', 1: 'neutral', 2: 'bullish'}[regime]
            print(f"  Regime {regime} ({regime_name}): {count:4d} bars ({pct:5.1f}%)")

print("\n### RSI STATISTICS ###")
for interval in ['base', 'mult1', 'mult2']:
    rsi_col = f'rsi_{interval}' if interval != 'base' else 'rsi_base'
    if rsi_col in features.columns:
        rsi = features[rsi_col]
        print(f"\n{interval} RSI stats:")
        print(f"  Mean: {rsi.mean():.4f}")
        print(f"  Std:  {rsi.std():.4f}")
        print(f"  Min:  {rsi.min():.4f}")
        print(f"  Max:  {rsi.max():.4f}")
        print(f"  < 0.15: {(rsi < 0.15).sum():4d} bars ({100*(rsi < 0.15).sum()/len(rsi):5.1f}%)")
        print(f"  > 0.85: {(rsi > 0.85).sum():4d} bars ({100*(rsi > 0.85).sum()/len(rsi):5.1f}%)")

print("\n### CROSSING EVENTS ###")
for interval in ['base', 'mult1', 'mult2']:
    cross_ob_col = f'cross_below_overbought_{interval}' if interval != 'base' else 'cross_below_overbought_base'
    cross_os_col = f'cross_above_oversold_{interval}' if interval != 'base' else 'cross_above_oversold_base'

    if cross_ob_col in features.columns:
        print(f"\n{interval} crossing events:")
        print(f"  Cross below overbought (0.85): {features[cross_ob_col].sum()} events")
        print(f"  Cross above oversold (0.15):  {features[cross_os_col].sum()} events")

print("\n" + "="*80)
print("CONSTANT FEATURES - WHY THEY'RE ZERO")
print("="*80)

for feat in constant_features:
    if feat not in features.columns:
        print(f"\n⚠️  {feat}: NOT IN DATASET")
        continue

    values = features[feat]
    n_nonzero = (values != 0).sum()

    print(f"\n{'='*80}")
    print(f"FEATURE: {feat}")
    print(f"{'='*80}")
    print(f"Non-zero bars: {n_nonzero}/{len(values)} ({100*n_nonzero/len(values):.2f}%)")
    print(f"Sum: {values.sum()}")

    # Explain the logic for each feature
    if feat == 'all_intervals_bearish':
        print("\nDESIGN:")
        print("  Triggers when: ALL 3 intervals have regime == 0 (RSI < 0.15)")
        print("  Purpose: Detect extreme market-wide oversold conditions")
        print("\nWHY CONSTANT:")
        bearish_base = (features['regime_base'] == 0).sum()
        bearish_mult1 = (features[f'regime_mult1'] == 0).sum() if 'regime_mult1' in features.columns else 0
        bearish_mult2 = (features[f'regime_mult2'] == 0).sum() if 'regime_mult2' in features.columns else 0
        print(f"  Base interval bearish:  {bearish_base}/{len(features)} bars")
        print(f"  Mult1 interval bearish: {bearish_mult1}/{len(features)} bars")
        print(f"  Mult2 interval bearish: {bearish_mult2}/{len(features)} bars")
        print("  → Random walk rarely produces RSI < 0.15 across ALL intervals simultaneously")
        print("  → Would need sustained selling pressure across multiple timeframes")

    elif feat == 'all_intervals_neutral':
        print("\nDESIGN:")
        print("  Triggers when: ALL 3 intervals have regime == 1 (0.15 <= RSI <= 0.85)")
        print("  Purpose: Detect market-wide consolidation/ranging")
        print("\nWHY CONSTANT:")
        neutral_base = (features['regime_base'] == 1).sum()
        neutral_mult1 = (features[f'regime_mult1'] == 1).sum() if 'regime_mult1' in features.columns else 0
        neutral_mult2 = (features[f'regime_mult2'] == 1).sum() if 'regime_mult2' in features.columns else 0
        print(f"  Base interval neutral:  {neutral_base}/{len(features)} bars")
        print(f"  Mult1 interval neutral: {neutral_mult1}/{len(features)} bars")
        print(f"  Mult2 interval neutral: {neutral_mult2}/{len(features)} bars")
        print("  → While individual intervals are often neutral, perfect 3-way alignment is rare")
        print("  → Different smoothing windows cause intervals to diverge")

    elif feat == 'all_intervals_crossed_overbought':
        print("\nDESIGN:")
        print("  Triggers when: ALL 3 intervals cross below 0.85 on the SAME bar")
        print("  Purpose: Detect synchronized overbought rejection across timeframes")
        print("\nWHY CONSTANT:")
        print("  → Requires ALL 3 intervals to be above 0.85, then cross below simultaneously")
        print("  → Base: 2h bars")
        print("  → Mult1: 8h bars (4× base)")
        print("  → Mult2: 24h bars (12× base)")
        print("  → Different timeframe smoothing makes simultaneous crossing nearly impossible")
        print("  → Would need extremely sharp reversal at exact time")

    elif feat == 'all_intervals_crossed_oversold':
        print("\nDESIGN:")
        print("  Triggers when: ALL 3 intervals cross above 0.15 on the SAME bar")
        print("  Purpose: Detect synchronized oversold recovery across timeframes")
        print("\nWHY CONSTANT:")
        print("  → Same logic as all_intervals_crossed_overbought")
        print("  → Multi-timeframe alignment makes simultaneous crossing extremely rare")

    elif feat == 'cascade_crossing_up':
        print("\nDESIGN:")
        print("  Triggers when: Sequential oversold crosses: mult2[i-2] → mult1[i-1] → base[i]")
        print("  Purpose: Detect momentum cascade from higher to lower timeframes")
        print("\nWHY CONSTANT:")
        cross_os_base = features['cross_above_oversold_base'].sum()
        cross_os_mult1 = features['cross_above_oversold_mult1'].sum() if 'cross_above_oversold_mult1' in features.columns else 0
        cross_os_mult2 = features['cross_above_oversold_mult2'].sum() if 'cross_above_oversold_mult2' in features.columns else 0
        print(f"  Base crosses oversold:  {cross_os_base} events")
        print(f"  Mult1 crosses oversold: {cross_os_mult1} events")
        print(f"  Mult2 crosses oversold: {cross_os_mult2} events")
        print("  → Requires precise 3-bar sequential timing")
        print("  → Random walk RSI rarely drops below 0.15")
        print("  → Even when it does, perfect 3-bar cascade is statistically unlikely")

    elif feat == 'cascade_crossing_down':
        print("\nDESIGN:")
        print("  Triggers when: Sequential overbought crosses: mult2[i-2] → mult1[i-1] → base[i]")
        print("  Purpose: Detect momentum cascade (distribution) from higher to lower timeframes")
        print("\nWHY CONSTANT:")
        cross_ob_base = features['cross_below_overbought_base'].sum()
        cross_ob_mult1 = features['cross_below_overbought_mult1'].sum() if 'cross_below_overbought_mult1' in features.columns else 0
        cross_ob_mult2 = features['cross_below_overbought_mult2'].sum() if 'cross_below_overbought_mult2' in features.columns else 0
        print(f"  Base crosses overbought:  {cross_ob_base} events")
        print(f"  Mult1 crosses overbought: {cross_ob_mult1} events")
        print(f"  Mult2 crosses overbought: {cross_ob_mult2} events")
        print("  → Same logic as cascade_crossing_up")
        print("  → Requires RSI > 0.85 AND perfect sequential timing")

    elif feat == 'gradient_up':
        print("\nDESIGN:")
        print("  Triggers when: rsi_base > rsi_mult1 > rsi_mult2")
        print("  Purpose: Detect momentum acceleration (RSI increases at lower timeframes)")
        print("\nWHY CONSTANT:")
        rsi_base = features['rsi_base']
        rsi_mult1 = features['rsi_mult1'] if 'rsi_mult1' in features.columns else None
        rsi_mult2 = features['rsi_mult2'] if 'rsi_mult2' in features.columns else None

        if rsi_mult1 is not None and rsi_mult2 is not None:
            base_gt_mult1 = (rsi_base > rsi_mult1).sum()
            mult1_gt_mult2 = (rsi_mult1 > rsi_mult2).sum()
            both = ((rsi_base > rsi_mult1) & (rsi_mult1 > rsi_mult2)).sum()

            print(f"  Base > Mult1: {base_gt_mult1}/{len(features)} bars")
            print(f"  Mult1 > Mult2: {mult1_gt_mult2}/{len(features)} bars")
            print(f"  Both (gradient_up): {both}/{len(features)} bars")
            print("\n  INSIGHT:")
            print("  → Higher timeframes smooth out volatility → higher RSI baseline")
            print("  → Lower timeframes react faster → lower RSI during consolidation")
            print("  → Typical pattern: rsi_mult2 > rsi_mult1 > rsi_base (OPPOSITE)")
            print("  → gradient_up requires REVERSAL of natural smoothing hierarchy")

print("\n" + "="*80)
print("SUMMARY: DESIGN RATIONALE")
print("="*80)

print("""
These 6 features were designed to capture RARE market events:

1. **all_intervals_bearish / all_intervals_neutral**
   - Theoretical: Perfect regime alignment across 3 timeframes
   - Reality: Different smoothing windows cause natural divergence
   - Would trigger: During extreme, sustained directional moves

2. **all_intervals_crossed_overbought / all_intervals_crossed_oversold**
   - Theoretical: Synchronized threshold crossings (flash crash/pump)
   - Reality: Multi-timeframe smoothing makes simultaneous crossing impossible
   - Would trigger: Only with EXACT timing at millisecond precision

3. **cascade_crossing_up / cascade_crossing_down**
   - Theoretical: Momentum cascade from higher to lower timeframes
   - Reality: Requires (1) extreme RSI, (2) perfect 3-bar timing
   - Would trigger: During parabolic moves with precise wave propagation

4. **gradient_up**
   - Theoretical: Momentum acceleration (lower TF faster than higher TF)
   - Reality: Natural smoothing creates OPPOSITE gradient (higher TF > lower TF)
   - Would trigger: During explosive breakouts that reverse smoothing hierarchy

VERDICT: These are "black swan" indicators that SHOULD be rare.
Their constant state (always 0) in typical datasets is BY DESIGN.
They would only activate during EXCEPTIONAL market conditions.

However, if they NEVER trigger even in 10,000+ bars across multiple
market regimes, they provide ZERO information and should be removed.
""")
