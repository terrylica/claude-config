#!/usr/bin/env python3
"""
Generic month downloader for OKX funding rates and tick data (SPOT + SWAP support).

Usage:
    python download_month_swap.py 2023 1                           # Jan 2023 spot (default)
    python download_month_swap.py 2023 1 --market-type swap        # Jan 2023 perpetuals
    python download_month_swap.py 2024 6 --ticks --market-type both # Jun 2024 both markets
"""

import sys
from pathlib import Path
import argparse
import pandas as pd
import httpx
from io import BytesIO
from zipfile import ZipFile
from datetime import datetime, timedelta

# Add okx-price-provider to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "libs" / "okx-price-provider" / "src"))

from okx_price_provider.cdn_downloader import download_month_ticks


def download_funding_rates_month(year: int, month: int, output_dir: Path):
    """Download funding rates for a single month."""

    print(f"\n{'='*80}")
    print(f"Downloading Funding Rates: {year}-{month:02d}")
    print('='*80)

    output_file = output_dir / f"{month:02d}.parquet"
    if output_file.exists():
        print(f"✓ Already exists: {output_file}")
        return output_file

    # Get all days in month
    start_date = datetime(year, month, 1)
    if month == 12:
        end_date = datetime(year + 1, 1, 1) - timedelta(days=1)
    else:
        end_date = datetime(year, month + 1, 1) - timedelta(days=1)

    all_rates = []

    for day in range(1, end_date.day + 1):
        url = f"https://www.okx.com/cdn/okex/traderecords/swaprate/monthly/{year}{month:02d}/allswaprate-swaprate-{year}-{month:02d}-{day:02d}.zip"

        try:
            print(f"  Downloading {year}-{month:02d}-{day:02d}...", end='', flush=True)

            resp = httpx.get(url, timeout=60, follow_redirects=True)
            resp.raise_for_status()

            with ZipFile(BytesIO(resp.content)) as zf:
                csv_name = [name for name in zf.namelist() if name.endswith('.csv')][0]
                with zf.open(csv_name) as csv_file:
                    df = pd.read_csv(csv_file, encoding='gbk')
                    df.columns = [col.split('/')[0] for col in df.columns]
                    all_rates.append(df)
                    print(f" {len(df):,} records")

        except Exception as e:
            print(f" ERROR: {e}")
            continue

    if not all_rates:
        print(f"ERROR: No data downloaded for {year}-{month:02d}")
        return None

    # Combine and save
    combined = pd.concat(all_rates, ignore_index=True)
    combined['timestamp'] = pd.to_datetime(combined['funding_time'], unit='ms', utc=True)
    combined = combined[['timestamp', 'instrument_name', 'funding_rate', 'real_funding_rate']].copy()
    combined.rename(columns={'instrument_name': 'symbol'}, inplace=True)
    combined['funding_rate'] = pd.to_numeric(combined['funding_rate'], errors='coerce')
    combined['real_funding_rate'] = pd.to_numeric(combined['real_funding_rate'], errors='coerce')

    output_dir.mkdir(parents=True, exist_ok=True)
    combined.to_parquet(output_file)

    print(f"✓ Saved {len(combined):,} funding rate records to {output_file}")
    return output_file


def download_ticks_month(year: int, month: int, output_dir: Path, market_type: str = "spot"):
    """Download tick data for a single month.

    Args:
        year: Year to download
        month: Month to download (1-12)
        output_dir: Directory to save parquet file
        market_type: 'spot' or 'swap'
    """

    market_label = "SPOT" if market_type == "spot" else "SWAP (Perpetual)"
    msg_type = "allspot" if market_type == "spot" else "allswap"

    print(f"\n{'='*80}")
    print(f"Downloading {market_label} Tick Data: {year}-{month:02d}")
    print('='*80)

    output_file = output_dir / f"{month:02d}.parquet"

    if output_file.exists():
        size_mb = output_file.stat().st_size / 1024 / 1024
        print(f"✓ Already exists: {output_file} ({size_mb:.0f} MB)")
        return output_file

    print(f"Downloading {market_type} tick data for {year}-{month:02d}...")

    output_dir.mkdir(parents=True, exist_ok=True)

    download_month_ticks(
        msg_type=msg_type,  # "allspot" or "allswap"
        year=year,
        month=month,
        output_parquet=output_file
    )

    size_mb = output_file.stat().st_size / 1024 / 1024
    df = pd.read_parquet(output_file)

    # Verify symbol suffixes
    if market_type == "swap":
        swap_symbols = [s for s in df['symbol'].unique() if '-SWAP' in s]
        print(f"✓ Saved {len(df):,} trades ({len(swap_symbols)} SWAP symbols) to {output_file} ({size_mb:.0f} MB)")
    else:
        print(f"✓ Saved {len(df):,} trades to {output_file} ({size_mb:.0f} MB)")

    return output_file


def main():
    parser = argparse.ArgumentParser(description='Download OKX data for a single month')
    parser.add_argument('year', type=int, help='Year (e.g., 2023)')
    parser.add_argument('month', type=int, help='Month (1-12)')
    parser.add_argument('--ticks', action='store_true', help='Also download tick data')
    parser.add_argument('--market-type', choices=['spot', 'swap', 'both'],
                       default='spot', help='Market type to download (default: spot)')
    parser.add_argument('--data-dir', type=Path, default=Path('data'),
                       help='Base data directory (default: data/)')

    args = parser.parse_args()

    # Validate
    if args.month < 1 or args.month > 12:
        print(f"ERROR: Month must be 1-12, got {args.month}")
        return 1

    print("="*80)
    print(f"Downloading Data: {args.year}-{args.month:02d} ({args.market_type.upper()})")
    print("="*80)

    # Download funding rates (always, same for all markets)
    funding_dir = args.data_dir / "funding_rates" / str(args.year)
    funding_file = download_funding_rates_month(args.year, args.month, funding_dir)

    if funding_file is None:
        print("\n❌ Failed to download funding rates")
        return 1

    # Download ticks (optional, large)
    if args.ticks:
        markets_to_download = ['spot', 'swap'] if args.market_type == 'both' else [args.market_type]

        for market in markets_to_download:
            # Use separate directories for spot and swap
            if market == 'swap':
                ticks_dir = args.data_dir / "raw_ticks_swap" / str(args.year)
            else:
                ticks_dir = args.data_dir / "raw_ticks" / str(args.year)

            ticks_file = download_ticks_month(args.year, args.month, ticks_dir, market_type=market)

            if ticks_file is None:
                print(f"\n❌ Failed to download {market} tick data")
                return 1

    print("\n" + "="*80)
    print("✅ DOWNLOAD COMPLETE")
    print("="*80)

    return 0


if __name__ == "__main__":
    sys.exit(main())
