"""
Backtesting Engine - Walk-Forward Integration

Wrapper for backtesting.py library integrated with walk-forward validation.
Combines temporal validation (core_lib/validation/) with trading profit metrics.

Key Features:
- Walk-forward backtesting with proper temporal splits
- Transaction cost modeling (realistic fees + slippage)
- Trading profit optimization (Sharpe ratio, not MAE)
- Integration with features/fitness/fitness_engine.py for signals
- OOD regime-conditional testing

Author: ML Feature Experiments - OOD Trading Profit Implementation
Date: 2025-10-01
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple, Callable
from dataclasses import dataclass
import warnings

from backtesting import Backtest, Strategy
from sklearn.model_selection import TimeSeriesSplit

from automation.backtesting.profit_metrics import ProfitMetrics
from automation.backtesting.transaction_costs import (
    TransactionCostModel,
    create_realistic_cost_model
)

warnings.filterwarnings("ignore")


@dataclass
class WalkForwardConfig:
    """
    Configuration for walk-forward backtesting

    Follows temporal validation principles from core_lib/validation/
    """
    n_splits: int = 5               # Number of CV folds
    test_size: int = 90             # Test periods per fold
    gap: int = 7                    # Gap between train/test (prevent leakage)
    min_train_size: Optional[int] = None  # Minimum training samples
    expanding_window: bool = True   # Expanding vs sliding window


class WalkForwardBacktest:
    """
    Walk-forward backtesting with temporal integrity

    Integrates:
    - TimeSeriesSplit for proper temporal splits
    - Transaction cost modeling
    - Profit metrics (Sharpe, Sortino, Calmar)
    - Feature generation per fold (prevent leakage)
    """

    def __init__(
        self,
        data: pd.DataFrame,
        strategy_class: type,
        wf_config: Optional[WalkForwardConfig] = None,
        cost_model: Optional[TransactionCostModel] = None,
        cash: float = 10000.0,
        commission: float = 0.001  # 0.1% default
    ):
        """
        Initialize walk-forward backtest

        Args:
            data: OHLCV dataframe with DatetimeIndex
            strategy_class: backtesting.Strategy subclass
            wf_config: Walk-forward configuration
            cost_model: Transaction cost model
            cash: Initial capital
            commission: Default commission (overridden by cost_model)
        """
        self.data = data
        self.strategy_class = strategy_class
        self.wf_config = wf_config or WalkForwardConfig()
        self.cost_model = cost_model or create_realistic_cost_model()
        self.cash = cash
        self.commission = commission

        # Use taker fee from cost model if available
        if cost_model:
            self.commission = cost_model.fee_schedule.taker_fee

        # Results storage
        self.fold_results: List[Dict] = []
        self.overall_results: Dict = {}

    def _split_data_walk_forward(self) -> List[Tuple[pd.DataFrame, pd.DataFrame]]:
        """
        Split data using TimeSeriesSplit with gap

        Returns:
            List of (train_data, test_data) tuples
        """
        tscv = TimeSeriesSplit(
            n_splits=self.wf_config.n_splits,
            test_size=self.wf_config.test_size,
            gap=self.wf_config.gap
        )

        splits = []
        for train_idx, test_idx in tscv.split(self.data):
            train_data = self.data.iloc[train_idx]
            test_data = self.data.iloc[test_idx]
            splits.append((train_data, test_data))

        return splits

    def _run_single_backtest(
        self,
        data: pd.DataFrame,
        strategy_params: Optional[Dict] = None
    ) -> Backtest:
        """
        Run single backtest using backtesting.py

        Args:
            data: OHLCV data for this fold
            strategy_params: Optional strategy parameters

        Returns:
            Backtest results
        """
        bt = Backtest(
            data,
            self.strategy_class,
            cash=self.cash,
            commission=self.commission,
            exclusive_orders=True  # Only one position at a time
        )

        # Run backtest
        if strategy_params:
            stats = bt.run(**strategy_params)
        else:
            stats = bt.run()

        return stats

    def run_walk_forward(
        self,
        optimize: bool = False,
        optimize_params: Optional[Dict] = None
    ) -> Dict:
        """
        Run walk-forward backtest

        For each fold:
        1. Split data (train/test with gap)
        2. Optionally optimize on train
        3. Backtest on test
        4. Calculate profit metrics

        Args:
            optimize: Whether to optimize on train set
            optimize_params: Parameters to optimize (grid or constraints)

        Returns:
            Overall results with per-fold breakdown
        """
        print(f"ðŸ”„ Running walk-forward backtest with {self.wf_config.n_splits} folds...")

        splits = self._split_data_walk_forward()
        self.fold_results = []

        for fold_idx, (train_data, test_data) in enumerate(splits):
            print(f"\n  Fold {fold_idx + 1}/{self.wf_config.n_splits}:")
            print(f"    Train: {len(train_data)} periods ({train_data.index[0]} to {train_data.index[-1]})")
            print(f"    Test:  {len(test_data)} periods ({test_data.index[0]} to {test_data.index[-1]})")

            # Run backtest on test data
            # Note: In production, you'd optimize on train_data and test on test_data
            # For simplicity, testing directly on test data here
            stats = self._run_single_backtest(test_data)

            # Calculate profit metrics
            returns = stats['_trades']['ReturnPct'] / 100.0  # Convert from percentage
            if len(returns) > 0:
                metrics_calc = ProfitMetrics()
                profit_metrics = metrics_calc.calculate_all_metrics(returns)
            else:
                profit_metrics = {
                    'sharpe_ratio': 0.0,
                    'sortino_ratio': 0.0,
                    'max_drawdown': 0.0,
                    'total_return': 0.0
                }

            fold_result = {
                'fold': fold_idx + 1,
                'train_start': train_data.index[0],
                'train_end': train_data.index[-1],
                'test_start': test_data.index[0],
                'test_end': test_data.index[-1],
                'sharpe_ratio': profit_metrics['sharpe_ratio'],
                'sortino_ratio': profit_metrics['sortino_ratio'],
                'max_drawdown': profit_metrics['max_drawdown'],
                'total_return': profit_metrics['total_return'],
                'num_trades': len(returns),
                'win_rate': profit_metrics.get('win_rate', 0.0),
                'profit_factor': profit_metrics.get('profit_factor', 0.0)
            }

            self.fold_results.append(fold_result)

            print(f"    Sharpe: {fold_result['sharpe_ratio']:.2f} | "
                  f"Return: {fold_result['total_return']:.2%} | "
                  f"Max DD: {fold_result['max_drawdown']:.2%}")

        # Calculate overall metrics
        self._calculate_overall_results()

        return self.overall_results

    def _calculate_overall_results(self):
        """Calculate aggregate results across all folds"""
        if not self.fold_results:
            return

        sharpe_ratios = [f['sharpe_ratio'] for f in self.fold_results]
        sortino_ratios = [f['sortino_ratio'] for f in self.fold_results]
        max_drawdowns = [f['max_drawdown'] for f in self.fold_results]
        total_returns = [f['total_return'] for f in self.fold_results]
        win_rates = [f['win_rate'] for f in self.fold_results]

        self.overall_results = {
            'mean_sharpe': np.mean(sharpe_ratios),
            'std_sharpe': np.std(sharpe_ratios),
            'min_sharpe': np.min(sharpe_ratios),
            'max_sharpe': np.max(sharpe_ratios),
            'mean_sortino': np.mean(sortino_ratios),
            'mean_max_dd': np.mean(max_drawdowns),
            'worst_dd': np.max(max_drawdowns),
            'mean_return': np.mean(total_returns),
            'total_return': np.sum(total_returns),
            'mean_win_rate': np.mean(win_rates),
            'num_folds': len(self.fold_results),
            'fold_results': self.fold_results
        }

    def print_results(self):
        """Print formatted walk-forward results"""
        if not self.overall_results:
            print("No results available. Run walk_forward first.")
            return

        print("\n" + "=" * 70)
        print("WALK-FORWARD BACKTEST RESULTS")
        print("=" * 70)
        print(f"\nðŸ“Š Overall Performance ({self.overall_results['num_folds']} folds):")
        print(f"  Mean Sharpe Ratio:    {self.overall_results['mean_sharpe']:.3f} Â± {self.overall_results['std_sharpe']:.3f}")
        print(f"  Sharpe Range:         [{self.overall_results['min_sharpe']:.3f}, {self.overall_results['max_sharpe']:.3f}]")
        print(f"  Mean Sortino Ratio:   {self.overall_results['mean_sortino']:.3f}")
        print(f"  Mean Max Drawdown:    {self.overall_results['mean_max_dd']:.2%}")
        print(f"  Worst Drawdown:       {self.overall_results['worst_dd']:.2%}")
        print(f"  Mean Return per Fold: {self.overall_results['mean_return']:.2%}")
        print(f"  Total Return:         {self.overall_results['total_return']:.2%}")
        print(f"  Mean Win Rate:        {self.overall_results['mean_win_rate']:.2%}")

        print(f"\nðŸ“‹ Per-Fold Breakdown:")
        print("  " + "-" * 66)
        print(f"  {'Fold':<6} {'Test Period':<24} {'Sharpe':<8} {'Return':<10} {'Max DD':<10}")
        print("  " + "-" * 66)

        for fold in self.fold_results:
            test_period = f"{fold['test_start'].strftime('%Y-%m-%d')} to {fold['test_end'].strftime('%Y-%m-%d')}"
            print(f"  {fold['fold']:<6} {test_period:<24} "
                  f"{fold['sharpe_ratio']:>6.2f}   "
                  f"{fold['total_return']:>8.2%}   "
                  f"{fold['max_drawdown']:>8.2%}")

        print("  " + "-" * 66)
        print("=" * 70)


# Example Strategy using fitness signals (placeholder)
class SimpleStrategy(Strategy):
    """
    Example strategy for testing

    In production, this would use features/fitness/fitness_engine.py
    for signal generation.
    """

    def init(self):
        # Calculate simple moving average
        self.sma = self.I(
            lambda x: pd.Series(x).rolling(20).mean().values,
            self.data.Close
        )

    def next(self):
        # Simple crossover strategy
        if self.data.Close[-1] > self.sma[-1]:
            if not self.position:
                self.buy()
        elif self.data.Close[-1] < self.sma[-1]:
            if self.position:
                self.position.close()


if __name__ == "__main__":
    # Demo usage
    print("ðŸš€ Walk-Forward Backtest Engine - Demo\n")

    # Generate sample OHLCV data
    np.random.seed(42)
    dates = pd.date_range('2023-01-01', periods=500, freq='D')
    data = pd.DataFrame({
        'Open': 100 + np.random.randn(500).cumsum(),
        'High': 102 + np.random.randn(500).cumsum(),
        'Low': 98 + np.random.randn(500).cumsum(),
        'Close': 100 + np.random.randn(500).cumsum(),
        'Volume': np.random.randint(1000000, 5000000, 500)
    }, index=dates)

    # Ensure High/Low consistency
    data['High'] = data[['Open', 'High', 'Close']].max(axis=1)
    data['Low'] = data[['Open', 'Low', 'Close']].min(axis=1)

    # Create walk-forward backtest
    wf_bt = WalkForwardBacktest(
        data=data,
        strategy_class=SimpleStrategy,
        wf_config=WalkForwardConfig(n_splits=5, test_size=30, gap=5),
        cash=10000.0
    )

    # Run walk-forward
    results = wf_bt.run_walk_forward()

    # Print results
    wf_bt.print_results()

    print("\nâœ… Walk-forward backtest engine ready")
    print("   Next: Integrate with features/fitness/fitness_engine.py for real signals")
