#!/usr/bin/env python3
"""
OKX Funding Arbitrage — V1.5 with VIP-7 Borrow Rate Scenarios

This version supports multiple borrow cost scenarios:
- harsh: Original harsh assumptions (BTC 4%, Alts 12%)
- vip7_conservative: VIP-7 with 85% discount
- vip7_moderate: VIP-7 with 90% discount (RECOMMENDED)
- vip7_optimistic: VIP-7 with 92% discount
- basic_tier: Actual basic tier rates (unprofitable, for comparison)

Usage:
    python3 funding_arb_strat_v1_5_vip7.py --scenario vip7_moderate

Author: Terry Li
Date: 2025-10-01
"""

import argparse
from collections import defaultdict
from datetime import timedelta
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path
import random

# =================== Configuration =================== #
CSV_PATH = Path(__file__).parent.parent / "data" / "okx_funding_2year_daily.csv"
INITIAL_EQUITY = 1.0
START_DATE = None  # Will use all available data
END_DATE   = None

# ===== BORROW COST SCENARIOS =====
# Based on OKX API data from Oct 1, 2025
# Basic tier: BTC 27.35%, Alts 103.25% (blended 84.28%)
# VIP-7 discount: 80-95% off basic tier

SCENARIOS = {
    'harsh': {
        'btc': 0.04,
        'alts': 0.12,
        'description': 'Original harsh assumptions (optimistic vs reality)',
        'label': 'V1.5 Harsh'
    },
    'vip7_conservative': {
        'btc': 0.0410,  # 85% discount from 27.35%
        'alts': 0.1549,  # 85% discount from 103.25%
        'description': 'VIP-7 conservative (85% discount)',
        'label': 'V1.5 VIP-7 (85%)'
    },
    'vip7_moderate': {
        'btc': 0.0274,  # 90% discount
        'alts': 0.1033,  # 90% discount
        'description': 'VIP-7 moderate (90% discount) - RECOMMENDED',
        'label': 'V1.5 VIP-7 (90%)'
    },
    'vip7_optimistic': {
        'btc': 0.0219,  # 92% discount
        'alts': 0.0826,  # 92% discount
        'description': 'VIP-7 optimistic (92% discount)',
        'label': 'V1.5 VIP-7 (92%)'
    },
    'basic_tier': {
        'btc': 0.2735,  # Actual basic tier as of Oct 2025
        'alts': 1.0325,  # Actual basic tier average
        'description': 'Basic tier reality (unprofitable)',
        'label': 'V1.5 Basic Tier'
    }
}

# ===== EXECUTION PARAMETERS (Same for all scenarios) =====
TAKER_FEE = 0.0002      # 2 bps
MAKER_FEE = 0.0002      # Assume 100% taker (worst case)
MAKER_RATIO = 0.0       # No maker fills (pessimistic)

SLIPPAGE_BPS = 3.0      # 3 bps per leg (conservative)
PARTIAL_FILL_RATIO = 0.90  # 90% execution, 10% missed

# Operational risk
OPS_SKIP_PROB_DAILY = 0.005  # 0.5% chance of daily skip

# Strategy parameters
TOP_N_SYMBOLS = 5
ENTRY_THRESHOLD_BPS = 4.0
REBALANCE_HOURS = 24
NO_TRADE_BAND = 0.10

# =================== Helper Functions =================== #

def compute_apy(start_equity: float, end_equity: float, days: float) -> float:
    """Compute annualized percentage yield (CAGR)"""
    if days <= 0 or start_equity <= 0:
        return 0.0
    years = days / 365.25
    return (end_equity / start_equity) ** (1 / years) - 1

def is_major_coin(symbol: str) -> bool:
    """Identify major coins for lower borrow rates"""
    majors = {'BTC', 'ETH'}
    return symbol in majors

# =================== Backtester =================== #

def run_backtest(scenario: str = 'vip7_moderate'):
    """Run backtest with specified borrow rate scenario"""

    if scenario not in SCENARIOS:
        raise ValueError(f"Unknown scenario '{scenario}'. Choose from: {list(SCENARIOS.keys())}")

    config = SCENARIOS[scenario]
    BORROW_APR_BTC = config['btc']
    BORROW_APR_ALTS = config['alts']

    print(f"\n{'='*70}")
    print(f"OKX Funding Arbitrage V1.5 — {config['label']}")
    print(f"{'='*70}")
    print(f"Scenario: {scenario}")
    print(f"Description: {config['description']}")
    print(f"Borrow rates: BTC {BORROW_APR_BTC*100:.2f}%, Alts {BORROW_APR_ALTS*100:.2f}%")
    print(f"{'='*70}\n")

    # Output paths
    OUT_CSV = Path(__file__).parent / f"okx_funding_arb_v1_5_{scenario}_results.csv"
    OUT_PNG = Path(__file__).parent / f"okx_funding_arb_v1_5_{scenario}_chart.png"

    # Load data
    print(f"[LOAD] Reading data from {CSV_PATH}...")
    df = pd.read_csv(CSV_PATH)

    # Standardize column names
    if 'funding_time' in df.columns:
        df['fundingTime'] = pd.to_datetime(df['funding_time'])
    if 'fundingRate' in df.columns:
        df['realFundingRate'] = df['fundingRate']

    df = df.sort_values("fundingTime").reset_index(drop=True)

    if START_DATE:
        df = df[df["fundingTime"] >= pd.to_datetime(START_DATE)]
    if END_DATE:
        df = df[df["fundingTime"] <= pd.to_datetime(END_DATE)]

    print(f"[INFO] Loaded {len(df):,} records")
    print(f"[INFO] Period: {df['fundingTime'].min()} → {df['fundingTime'].max()}")
    print(f"[INFO] Symbols: {df['symbol'].nunique()}")

    # Initialize state
    equity = INITIAL_EQUITY
    holdings = {}  # {symbol: weight}
    last_rebalance = None

    # Tracking
    equity_curve = []
    borrow_costs = []
    slippage_costs = []
    missed_hedge_costs = []
    ops_skips = 0

    # Group by funding period
    grouped = df.groupby("fundingTime")

    for funding_time, group in grouped:
        # Check operational skip
        if random.random() < OPS_SKIP_PROB_DAILY:
            ops_skips += 1
            equity_curve.append((funding_time, equity))
            continue

        # Rebalance check
        need_rebalance = (
            last_rebalance is None or
            (funding_time - last_rebalance).total_seconds() / 3600 >= REBALANCE_HOURS
        )

        if need_rebalance:
            # Select top N symbols by abs(funding rate)
            group = group.copy()
            group["abs_rate"] = group["realFundingRate"].abs()
            top = group.nlargest(TOP_N_SYMBOLS, "abs_rate")

            # Filter by entry threshold
            top = top[top["abs_rate"] >= ENTRY_THRESHOLD_BPS / 10000]

            if len(top) == 0:
                equity_curve.append((funding_time, equity))
                continue

            # Calculate new weights (equal-weighted)
            new_holdings = {row["symbol"]: 1.0 / len(top) for _, row in top.iterrows()}

            # Calculate turnover
            old_set = set(holdings.keys())
            new_set = set(new_holdings.keys())
            to_add = new_set - old_set
            to_remove = old_set - new_set
            to_adjust = old_set & new_set

            # Exit costs (selling old positions)
            for sym in to_remove:
                weight = holdings[sym]
                # Apply no-trade band
                if abs(weight) < NO_TRADE_BAND:
                    continue

                exit_cost = weight * (TAKER_FEE + SLIPPAGE_BPS / 10000)
                equity -= exit_cost
                slippage_costs.append((funding_time, exit_cost))

            # Entry costs (buying new positions)
            for sym in to_add:
                weight = new_holdings[sym]
                # Apply no-trade band
                if abs(weight) < NO_TRADE_BAND:
                    continue

                entry_cost = weight * (TAKER_FEE + SLIPPAGE_BPS / 10000)
                equity -= entry_cost
                slippage_costs.append((funding_time, entry_cost))

            # Adjustment costs (rebalancing existing)
            for sym in to_adjust:
                old_weight = holdings[sym]
                new_weight = new_holdings[sym]
                delta = abs(new_weight - old_weight)

                if delta < NO_TRADE_BAND:
                    continue

                adj_cost = delta * (TAKER_FEE + SLIPPAGE_BPS / 10000)
                equity -= adj_cost
                slippage_costs.append((funding_time, adj_cost))

            # Partial fill penalty
            for sym in (to_add | to_adjust):
                if random.random() > PARTIAL_FILL_RATIO:
                    # Missed hedge - assume 1% loss from unhedged exposure
                    miss_cost = new_holdings[sym] * 0.01
                    equity -= miss_cost
                    missed_hedge_costs.append((funding_time, miss_cost))

            holdings = new_holdings
            last_rebalance = funding_time

        # Collect funding
        for sym, weight in holdings.items():
            sym_row = group[group["symbol"] == sym]
            if sym_row.empty:
                continue

            rate = sym_row.iloc[0]["realFundingRate"]
            pnl = weight * rate
            equity += pnl

        # Apply borrow costs (hourly, for 8-hour period)
        period_hours = 8
        for sym, weight in holdings.items():
            sym_row = group[group["symbol"] == sym]
            if sym_row.empty:
                continue

            rate = sym_row.iloc[0]["realFundingRate"]

            # Only pay borrow on short spot (negative funding = long perp + short spot)
            if rate < 0:
                # Determine borrow rate
                borrow_apr = BORROW_APR_BTC if is_major_coin(sym) else BORROW_APR_ALTS
                hourly_rate = borrow_apr / (365.25 * 24)
                borrow_cost = weight * hourly_rate * period_hours
                equity -= borrow_cost
                borrow_costs.append((funding_time, borrow_cost))

        equity_curve.append((funding_time, equity))

    # Convert to DataFrame
    equity_df = pd.DataFrame(equity_curve, columns=["date", "equity"])
    equity_df = equity_df.sort_values("date").reset_index(drop=True)

    # Calculate metrics
    start_equity = equity_df.iloc[0]["equity"]
    end_equity = equity_df.iloc[-1]["equity"]
    days = (equity_df.iloc[-1]["date"] - equity_df.iloc[0]["date"]).days
    apy = compute_apy(start_equity, end_equity, days)

    # Calculate Sharpe (using daily returns)
    equity_df["returns"] = equity_df["equity"].pct_change()
    sharpe = equity_df["returns"].mean() / equity_df["returns"].std() * np.sqrt(365.25) if equity_df["returns"].std() > 0 else 0

    # Summarize costs
    total_borrow = sum(c for _, c in borrow_costs) if borrow_costs else 0
    total_slippage = sum(c for _, c in slippage_costs) if slippage_costs else 0
    total_missed = sum(c for _, c in missed_hedge_costs) if missed_hedge_costs else 0

    # Print results
    print(f"\n{'='*70}")
    print(f"RESULTS — {config['label']}")
    print(f"{'='*70}")
    print(f"Period:         {equity_df.iloc[0]['date'].date()} to {equity_df.iloc[-1]['date'].date()} ({days} days)")
    print(f"Start equity:   {start_equity:.4f}")
    print(f"End equity:     {end_equity:.4f}")
    print(f"Total return:   {(end_equity - start_equity) * 100:.2f}%")
    print(f"APY (CAGR):     {apy * 100:.2f}%")
    print(f"Sharpe ratio:   {sharpe:.2f}")
    print(f"\nCost Breakdown:")
    print(f"  Borrow costs:       {total_borrow * 100:.2f}% ({total_borrow / (days / 365.25) * 100:.2f}% APY drag)")
    print(f"  Slippage:           {total_slippage * 100:.2f}%")
    print(f"  Missed hedges:      {total_missed * 100:.2f}%")
    print(f"  Ops skips:          {ops_skips} events")
    print(f"{'='*70}\n")

    # Save results
    equity_df.to_csv(OUT_CSV, index=False)
    print(f"[SAVE] Results saved to {OUT_CSV}")

    # Plot
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10))

    # Equity curve
    ax1.plot(equity_df["date"], equity_df["equity"], linewidth=2, color='#2E86AB')
    ax1.set_title(f"{config['label']} — Equity Curve", fontsize=14, fontweight='bold')
    ax1.set_xlabel("Date (UTC)")
    ax1.set_ylabel("Equity (normalized)")
    ax1.grid(True, alpha=0.3)
    ax1.axhline(y=1.0, color='gray', linestyle='--', linewidth=1, alpha=0.5)

    # Cumulative costs
    if borrow_costs or slippage_costs or missed_hedge_costs:
        cost_df = pd.DataFrame(
            [(t, c, 'Borrow') for t, c in borrow_costs] +
            [(t, c, 'Slippage') for t, c in slippage_costs] +
            [(t, c, 'Missed Hedges') for t, c in missed_hedge_costs],
            columns=['date', 'cost', 'type']
        )
        cost_df = cost_df.sort_values('date')

        for cost_type, color in [('Borrow', '#E63946'), ('Slippage', '#F77F00'), ('Missed Hedges', '#06A77D')]:
            subset = cost_df[cost_df['type'] == cost_type]
            if not subset.empty:
                subset = subset.copy()
                subset['cumulative'] = subset['cost'].cumsum()
                ax2.plot(subset['date'], subset['cumulative'], label=cost_type, linewidth=2, color=color)

        ax2.set_title("Cumulative Costs Over Time", fontsize=14, fontweight='bold')
        ax2.set_xlabel("Date (UTC)")
        ax2.set_ylabel("Cumulative Cost")
        ax2.legend()
        ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(OUT_PNG, dpi=150, bbox_inches='tight')
    print(f"[SAVE] Chart saved to {OUT_PNG}")

    return {
        'scenario': scenario,
        'apy': apy,
        'sharpe': sharpe,
        'final_equity': end_equity,
        'total_borrow': total_borrow,
        'total_slippage': total_slippage,
        'total_missed': total_missed
    }

# =================== Main =================== #

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='OKX Funding Arbitrage V1.5 with VIP-7 Borrow Scenarios',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available scenarios:
  harsh               : Original harsh assumptions (BTC 4%, Alts 12%)
  vip7_conservative   : VIP-7 with 85% discount (BTC 4.1%, Alts 15.5%)
  vip7_moderate       : VIP-7 with 90% discount (BTC 2.7%, Alts 10.3%) [RECOMMENDED]
  vip7_optimistic     : VIP-7 with 92% discount (BTC 2.2%, Alts 8.3%)
  basic_tier          : Actual basic tier rates (BTC 27.4%, Alts 103.3%) [unprofitable]

Examples:
  python3 funding_arb_strat_v1_5_vip7.py --scenario vip7_moderate
  python3 funding_arb_strat_v1_5_vip7.py --scenario harsh
  python3 funding_arb_strat_v1_5_vip7.py --all
        """
    )
    parser.add_argument('--scenario', type=str, default='vip7_moderate',
                        help='Borrow rate scenario to test')
    parser.add_argument('--all', action='store_true',
                        help='Run all scenarios and generate comparison')

    args = parser.parse_args()

    if args.all:
        print("\n" + "="*70)
        print("Running ALL scenarios for comparison...")
        print("="*70 + "\n")

        results = []
        for scenario in ['harsh', 'vip7_conservative', 'vip7_moderate', 'vip7_optimistic']:
            result = run_backtest(scenario)
            results.append(result)

        # Create comparison table
        print("\n" + "="*70)
        print("SCENARIO COMPARISON")
        print("="*70)
        print(f"{'Scenario':<20} {'APY %':<12} {'Sharpe':<10} {'Borrow Drag pp':<15}")
        print("-"*70)
        for r in results:
            borrow_drag = r['total_borrow'] * 100 / (2 / 365.25)  # Annualized
            print(f"{r['scenario']:<20} {r['apy']*100:<12.2f} {r['sharpe']:<10.2f} {borrow_drag:<15.2f}")
        print("="*70 + "\n")

    else:
        run_backtest(args.scenario)
