# Insurance Project Memory

**Architecture**: Link Farm + Hub-and-Spoke with Progressive Disclosure

**Purpose**: Personal insurance automation and credential management

**Documentation Hub**: [`docs/INDEX.md`](/Users/terryli/own/insurance/docs/INDEX.md)

---

## Quick Links

**Architecture**: [`docs/architecture/`](/Users/terryli/own/insurance/docs/architecture/) - Page Object Model design and test strategy
**Specifications**: [`specifications/`](/Users/terryli/own/insurance/specifications/) - OpenAPI 3.1.0 specs
**Tests**: [`tests/`](/Users/terryli/own/insurance/tests/) - Pytest reconnaissance and automation
**Page Objects**: [`pages/`](/Users/terryli/own/insurance/pages/) - Reusable page classes
**Workflows**: [`docs/workflows/`](/Users/terryli/own/insurance/docs/workflows/) - Authentication, HITL review, credential sync
**Audit**: [`docs/AUDIT.md`](/Users/terryli/own/insurance/docs/AUDIT.md) - API verification (v1.1.0)
**Decisions**: [`docs/decisions/`](/Users/terryli/own/insurance/docs/decisions/) - Technology evaluations

---

## Current Status (2025-10-18)

**Phase**: Phase 1 - Discovery (Phase 6 exploration complete)
**Version**: Architecture v2.0.0

**Recent Milestones** âœ…:
- âœ… **Phase 6**: Explored 19 form variations (age, amount, product types, smoking status)
- âœ… **Authentication**: Fixed `.type()` delay requirement for React forms
- âœ… **POM Foundation**: Base page class with custom React component handling
- âœ… **HITL Workflow**: GitHub Issues-based review workflow (v1.0.0)
- âœ… **Project Structure**: Validated against Playwright best practices

**Phase 6 Exploration** (2025-10-17):
- Explored 19 form variations across age, coverage amount, product combinations
- Discovered `additional_products=Yes` creates unfilled conditional field
- Validated authentication pattern using `.type()` with 50ms delay
- See: [`docs/analysis/phase-6-exploration-analysis.md`](/Users/terryli/own/insurance/docs/analysis/phase-6-exploration-analysis.md)

**HITL Review Workflow** (2025-10-18):
- GitHub Issues-based approval workflow for AI-human collaboration
- Blocking execution until human approves/rejects via comment keywords
- Artifacts branch for permanent screenshot URLs
- See: [`docs/workflows/human-in-the-loop-review.md`](/Users/terryli/own/insurance/docs/workflows/human-in-the-loop-review.md) (v1.0.0)

**Next**: Continue form exploration or begin Phase 2 documentation

**Key Docs**:
- [`docs/architecture/test-strategy.md`](/Users/terryli/own/insurance/docs/architecture/test-strategy.md) (v1.0.0) - 3-phase strategy
- [`docs/analysis/custom-react-components-spike.md`](/Users/terryli/own/insurance/docs/analysis/custom-react-components-spike.md) - Custom component solution
- [`docs/analysis/manulife-par-field-catalog.md`](/Users/terryli/own/insurance/docs/analysis/manulife-par-field-catalog.md) (v1.0.0) - Field inventory

---

## Credential Management

**Doppler Project**: `insurance` (production config: `prd`)

**Access Pattern**:
```bash
doppler run --project insurance --config prd -- <command>
```

**View Secrets**:
```bash
doppler secrets --project insurance --config prd
```

**Current Credentials**:
- Manulife Par Account (`MANULIFE_PAR_USERNAME`, `MANULIFE_PAR_PASSWORD`)
- Manulife Passkey (`MANULIFE_PAR_PASSKEY_*`) - For CDP WebAuthn automation

**Migration Workflow**: [`docs/workflows/credential-sync.md`](/Users/terryli/own/insurance/docs/workflows/credential-sync.md)
**Auth Implementation**: [`docs/workflows/authentication-implementation.md`](/Users/terryli/own/insurance/docs/workflows/authentication-implementation.md)

---

## Playwright Automation

**Framework**: Playwright (Python) with `uv`
**Authentication**: Passkey via `storage-state.json` (gitignored)
**Artifacts**: Screenshots, DOM dumps, HAR, trace, telemetry (no video)

**Key Features**:
- **PII-safe**: Masked screenshots, log keys only
- **ARIA-first selectors**: Stable, accessibility-driven targeting
- **Comprehensive capture**: HAR, trace with snapshots, telemetry NDJSON
- **Iframe-proof**: Automatic frame detection
- **Offline replay**: `routeFromHAR` for analysis

**Usage**:
```bash
# Reconnaissance (discovery only, no submission)
doppler run --project insurance --config prd -- \
  uv run --active pytest -v -m reconnaissance tests/reconnaissance/

# Automation (fill form, controlled submission) - Phase 3
export FORM_JSON='{"first_name":"Ada",...}'
export SUBMIT=true  # Omit or set false for dry-run
doppler run --project insurance --config prd -- \
  uv run --active pytest -v tests/automation/fill_par_form.py
```

**Documentation**: [`docs/automation/manulife-par.md`](/Users/terryli/own/insurance/docs/automation/manulife-par.md)
**Specification**: [`specifications/playwright-automation.yaml`](/Users/terryli/own/insurance/specifications/playwright-automation.yaml)

---

## ðŸ“¸ Visual Inspection Mandate

**STATUS**: MANDATORY for all reconnaissance, spike, and exploratory work
**ENFORCEMENT**: Pre-commit hook + CI/CD validation

### Why This Matters

**2025-10-17 Critical Discovery**: Reconnaissance on Manulife Par form found a selector bug ONLY through PNG examination:
- Overly broad selector `page.locator("select, [role='combobox']").filter(has_text="Select").first`
- Accidentally changed product from "Manulife Par" to "Family Term"
- ARIA tree comparison showed **NO DIFFERENCE** (same structure, different content)
- PNG screenshot clearly showed wrong product selected
- **Impact**: Would have caused 4+ hours of debugging in implementation phase vs. 30 seconds to catch visually

**Lesson**: Screenshots are NOT optional documentation â€” they are MANDATORY evidence that catches issues invisible in ARIA/DOM analysis.

### Mandatory Workflow

**FOR EVERY RECONNAISSANCE OR SPIKE:**

#### 1. Capture Screenshots at Each Step

```python
# After EVERY significant action
artifact_manager.capture_screenshot(page, "step_description")
```

**Minimum Requirements**:
- [ ] Initial state (`001_initial.png`)
- [ ] After each interaction (`002_*.png`, `003_*.png`, etc.)
- [ ] Final state (`00N_final.png`)

#### 2. Examine EACH Screenshot (Not Just Generate)

**Agent Reflection Pattern** - STOP after each screenshot:

```markdown
## Visual Inspection: [step_name].png

**What I See**:
- [Describe visible elements, state, layout]

**Expected vs. Actual**:
- âœ… Product dropdown shows "Manulife Par" [as expected]
- âœ… Form fields match expected structure [as expected]
- âš ï¸  Blue banner visible [unexpected but harmless]

**PII Check**: âœ… No sensitive data visible / âœ… PII properly masked

**Action**: Proceed / Investigate discrepancy / Document finding
```

#### 3. Document in Report

**Link screenshots to findings**:

```markdown
## Step 2: Product Selection

See: `artifacts/recon_20251017/002_product_selected.png`

**Visual Verification**:
- Product dropdown correctly shows "Manulife Par"
- "Upload Later" radio selected as expected
- No unexpected state changes observed
```

### Pre-Commit Checklist

Before committing reconnaissance work:

- [ ] **Minimum 3 screenshots captured**
- [ ] **ALL screenshots visually examined** (describe what you saw)
- [ ] **Any visual discrepancies investigated**
- [ ] **PII masking verified** by visual inspection
- [ ] **Findings reference screenshots** in report.md
- [ ] **Manifest includes screenshot inventory** (index.json)

**ENFORCEMENT**: Pre-commit hook validates screenshot count and report references.

### Quick Reference: Good vs. Bad

âœ… **GOOD**:
```markdown
## Step: Fill Product Dropdown

Screenshot: `002_product_selected.png`

Visual Check:
- âœ… Product shows "Manulife Par"
- âœ… Upload Later selected
- âœ… Form fields match Par structure

Conclusion: Proceed to next step.
```

âŒ **BAD**:
```markdown
## Artifacts
- 001.png
- 002.png
- 003.png

Next: Implement automation.
```
*Problem: No evidence screenshots were examined, no visual verification, no findings.*

### Enforcement

**Pre-Commit Hook**: Validates minimum 3 screenshots + report references
**CI/CD**: Blocks PR if artifacts incomplete
**See**: [`docs/analysis/visual-inspection-enforcement-proposal.md`](/Users/terryli/own/insurance/docs/analysis/visual-inspection-enforcement-proposal.md)

---

## Human-in-the-Loop Review Workflow

**Method**: GitHub Issues with artifacts branch
**Blocking**: Yes (AI waits for approval via comment polling)
**Repository**: https://github.com/tainora/insurance
**Documentation**: [`docs/workflows/human-in-the-loop-review.md`](/Users/terryli/own/insurance/docs/workflows/human-in-the-loop-review.md) (pending)

### Overview

AI coding agents can request human review by creating GitHub Issues with embedded screenshots and test results. The agent **blocks execution** and polls the issue for approval/rejection keywords in comments.

**Use Cases**:
- Pre-submission approval for live tests (prevent accidental submissions)
- Review of visual anomalies or unexpected behaviors
- Validation of new conditional logic discovered during exploration
- Milestone achievements requiring human confirmation

### Review Triggers (4 Types)

AI creates review issues when detecting:

1. **Visual Anomalies**: Unexpected page height changes, missing/new elements, layout shifts
2. **New Conditional Logic**: Form fields appearing/disappearing based on choices
3. **Unknown Validation Errors**: "Required" errors, ambiguous validation messages
4. **Milestone Achievements**: Phase completions, successful explorations, test passes

### Workflow

```
1. AI detects trigger condition during test execution
2. AI uploads screenshots to `artifacts` branch (orphan branch)
3. AI creates GitHub Issue with embedded images using raw GitHub URLs
4. AI execution PAUSES - polls issue every 30s for approval
5. Human reviews issue, adds comment with approval/rejection keyword
6. AI continues (approved) or halts (rejected) based on comment
```

**Artifacts Branch**: Orphan branch separate from main codebase, stores binary artifacts
**URL Format**: `https://raw.githubusercontent.com/tainora/insurance/COMMIT_SHA/path/screenshot.png`

### Approval Keywords

**To Approve and Unblock**:
- `approved`, `lgtm`, `looks good`, `approve`, âœ…

**To Reject and Halt**:
- `rejected`, `reject`, `changes requested`, `not approved`, âŒ

**Timeout**: 3600s (1 hour) default - returns "timeout" status

### Usage Examples

**Async Review (Non-Blocking)**:
```python
from utils.github_review import create_review_request

# Create review issue without blocking
issue = create_review_request(
    test_name="Manulife PAR Form Fill - Stage 2",
    test_type="reconnaissance",
    summary="Form filled successfully, ready for validation",
    artifacts_urls={"screenshot.png": "https://raw.githubusercontent.com/..."},
    trigger_reason="Milestone Achievement",
    blocking=False  # AI continues without waiting
)

print(f"Review requested: {issue['url']}")
```

**Blocking Review (AI Waits)**:
```python
from utils.github_review import create_review_request, wait_for_approval

# Create review issue
issue = create_review_request(
    test_name="Submit Manulife Form",
    test_type="automation-live",
    summary="Ready to submit form with live data",
    artifacts_urls=artifacts_urls,
    trigger_reason="Pre-Submission Approval (Live Test)",
    blocking=True  # Indicates urgency
)

# Block until approved
status = wait_for_approval(issue['number'], timeout=3600)

if status == "approved":
    print("Proceeding with submission")
    submit_form()
elif status == "rejected":
    print("Submission cancelled by human reviewer")
    raise Exception("Human review rejected")
else:  # timeout
    print("Review timeout - aborting")
    raise TimeoutError("No response from human reviewer")
```

**Decorator Pattern (Function-Level Approval Gate)**:
```python
from utils.approval_gate import require_approval

@require_approval(
    test_name="Submit Manulife Form",
    test_type="automation-live",
    summary="Ready to submit form with live data",
    artifacts_dir=Path("./artifacts/2025-10-18_14-30-00"),
    trigger_reason="Pre-Execution Approval Gate"
)
def submit_form(page):
    """Submit form - requires human approval before execution."""
    page.click("button[type='submit']")
    page.wait_for_load_state("networkidle")

# When called, creates review issue and blocks until approved
submit_form(page)  # Pauses here for human approval
```

**Dynamic Approval Context**:
```python
from utils.approval_gate import require_approval_with_context

def get_summary(page, form_data):
    return f"About to submit form for: {form_data['first_name']} {form_data['last_name']}"

def capture_artifacts(page, form_data):
    artifacts = Path("./artifacts/pre_submit")
    artifacts.mkdir(exist_ok=True)
    page.screenshot(path=artifacts / "form_state.png")
    return artifacts

@require_approval_with_context(
    test_name="Submit Form",
    summary_fn=get_summary,
    artifacts_fn=capture_artifacts
)
def submit_form(page, form_data):
    page.click("button[type='submit']")

# Summary and artifacts generated from function arguments
submit_form(page, {"first_name": "Ada", "last_name": "Lovelace"})
```

### Utilities

**`utils/artifact_uploader.py`** [`/Users/terryli/own/insurance/utils/artifact_uploader.py`](/Users/terryli/own/insurance/utils/artifact_uploader.py):
- `upload_artifacts()` - Upload directory to artifacts branch, return GitHub URLs
- `generate_markdown_image_links()` - Generate markdown for embedding in issues

**`utils/github_review.py`** [`/Users/terryli/own/insurance/utils/github_review.py`](/Users/terryli/own/insurance/utils/github_review.py):
- `create_review_request()` - Create GitHub Issue for human review
- `wait_for_approval()` - Block until issue approved/rejected
- `list_pending_reviews()` - List all open review issues

**`utils/approval_gate.py`** [`/Users/terryli/own/insurance/utils/approval_gate.py`](/Users/terryli/own/insurance/utils/approval_gate.py):
- `@require_approval` - Decorator for function-level approval gates
- `@require_approval_with_context` - Decorator with access to function arguments

### GitHub Issue Template

**Template**: [`.github/ISSUE_TEMPLATE/ai-review-request.yml`](/Users/terryli/own/insurance/.github/ISSUE_TEMPLATE/ai-review-request.yml)

**Labels**:
- `needs-human-review` - AI awaiting human review
- `approved` - Human approved
- `rejected` - Human rejected
- `reconnaissance` / `automation-dry-run` / `automation-live` - Test type
- `blocking` - Urgent review needed

**Assignee**: Auto-assigned to repository owner (`@me`)

### Integration with Tests

**Reconnaissance Tests** (optional integration):
```python
# In tests/reconnaissance/explore_full_form.py
from utils.github_review import create_review_request

# After discovering new conditional logic
if new_fields_appeared:
    create_review_request(
        test_name="New Conditional Fields Discovered",
        test_type="reconnaissance",
        summary=f"Fields appeared when selecting {choice}",
        artifacts_urls=upload_artifacts(artifacts_dir, "tainora", "insurance"),
        trigger_reason="New Conditional Logic Discovered",
        blocking=False  # Don't block exploration
    )
```

**Automation Tests** (blocking approval before submission):
```python
# In tests/automation/fill_par_form.py
from utils.approval_gate import require_approval

@require_approval(
    test_name="Manulife PAR Form Submission",
    test_type="automation-live",
    trigger_reason="Pre-Submission Approval (Live Test)"
)
def submit_par_form(page):
    """Submit PAR form - requires human approval."""
    page.click("button[type='submit']")
```

### Security Considerations

- **Private Repository**: Artifacts stored in private repo, images respect repository permissions
- **PII Masking**: Screenshots should be PII-masked before upload (existing requirement)
- **Credential Safety**: No secrets in issue bodies or artifacts
- **Branch Isolation**: Artifacts branch is orphan (separate history from main)

---

## Authentication

**Method**: Automated passkey via CDP WebAuthn â†’ `storage-state.json`
**Module**: [`auth/passkey_authenticator.py`](/Users/terryli/own/insurance/auth/passkey_authenticator.py)
**Implementation**: [`docs/workflows/authentication-implementation.md`](/Users/terryli/own/insurance/docs/workflows/authentication-implementation.md) (v1.0.0)

**Usage**:
```bash
# CLI script
doppler run --project insurance --config prd -- \
  uv run --active python -m auth.passkey_authenticator

# As module (in tests/code)
from auth.passkey_authenticator import PasskeyAuthenticator
authenticator = PasskeyAuthenticator(...)
storage_state = authenticator.authenticate()
```

---

## Implementation Strategy

**Approach**: Systematic 3-phase strategy for complex multi-page forms

**Phase 0 - Structural Foundation** âœ… (COMPLETED 2025-10-17)
- Restructure project to follow Playwright best practices
- Page Object Model architecture
- Shared utilities and pytest fixtures
- Modular page-level specifications

**Phase 1 - Systematic Discovery** (NEXT)
- Explore complete multi-page form structure
- Capture artifacts at each page transition
- Document page inventory and field catalog
- Map state transitions and conditional logic

**Phase 2 - Structured Documentation**
- Design page object classes for each form page
- Create comprehensive specifications
- Define test data sets

**Phase 3 - Modular Implementation**
- Implement page objects using base class
- Build form orchestrator
- Test dry-run and live submission modes

**Rationale**: Multi-page forms require systematic exploration before automation - discover structure â†’ document specs â†’ implement deterministically

**Full Strategy**: [`docs/architecture/test-strategy.md`](/Users/terryli/own/insurance/docs/architecture/test-strategy.md) (v1.0.0)
**Alternative Considered**: Stagehand - See [`docs/decisions/stagehand-evaluation.md`](/Users/terryli/own/insurance/docs/decisions/stagehand-evaluation.md)

---

## Page Object Model (POM) Best Practices

**Status**: MANDATORY for all production automation (validated 2025-10-17)
**Reference**: [Playwright Official POM Docs](https://playwright.dev/python/docs/pom)

### Core Principles

**Official Playwright Guidance:**
> "If you use page objects, then all interactions should be performed using page objects. It is not recommended to mix raw Playwright calls (except expect assertions) with page object calls."

### Pattern Structure

```python
# pages/base_page.py - Common patterns for all pages
class BasePage:
    def __init__(self, page):
        self.page = page

    def navigate_to(self, url):
        """Navigate with proper waiting"""
        self.page.goto(url, wait_until="networkidle")

    def dispatch_click_event(self, selector):
        """Handle custom React components requiring JS dispatch"""
        self.page.evaluate(f"""
            const btn = document.querySelector('{selector}');
            btn.click();
            btn.dispatchEvent(new Event('change', {{ bubbles: true }}));
        """)

# pages/manulife_par_page.py - Form-specific logic
class ManulifeParPage(BasePage):
    def __init__(self, page):
        super().__init__(page)

    @property
    def first_name_input(self):
        return self.page.get_by_role("textbox", name="First name")

    def fill_first_name(self, name):
        """Fill first name field with ARIA-first selector"""
        self.first_name_input.fill(name)

    def select_riders(self, choice):
        """Select riders using custom component pattern"""
        button_id = "RIDER_STATUS_ID-0" if choice == "Yes" else "RIDER_STATUS_ID-1"
        self.dispatch_click_event(f"#{button_id}")
        self.page.wait_for_timeout(500)  # Allow React state update
```

### Usage in Tests

```python
# tests/e2e/test_fill_par_form.py
def test_fill_basic_info(page):
    # Use page object, not raw Playwright calls
    manulife_page = ManulifeParPage(page)
    manulife_page.navigate_to(WELCOME_URL)
    manulife_page.fill_first_name("John")
    manulife_page.select_riders("No")

    # Assertions can use raw Playwright
    assert page.get_by_text("John").is_visible()
```

### Custom React Components

**Critical Discovery (2025-10-17)**: Manulife form uses custom `<button role="radio">` components that require JavaScript event dispatch.

**Problem**: Standard Playwright `.click()` doesn't trigger React synthetic event handlers
**Solution**: Use `element.click()` + `dispatchEvent(new Event('change'))`
**Affected Fields**: 4 custom radio components (Riders, Quebec, Additional Products, Medical Info)

**Documentation**: [`docs/analysis/custom-react-components-spike.md`](/Users/terryli/own/insurance/docs/analysis/custom-react-components-spike.md)

### Benefits

- **Maintainability**: Changes centralized in page objects, not scattered across tests
- **Reusability**: Common patterns (JS dispatch) abstracted in `BasePage`
- **Readability**: Tests read like user workflows, not technical operations
- **Reliability**: Decoupled test logic from page implementation details

### Directory Structure

```
pages/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ base_page.py                  # Common patterns (navigation, JS dispatch)
â”œâ”€â”€ manulife_par_page.py          # Main form page object
â””â”€â”€ components/                   # Reusable components
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ custom_radio.py           # Abstract custom React button pattern
    â””â”€â”€ coverage_section.py       # Reusable form section
```

### Reconnaissance vs Production Tests

**Reconnaissance Tests** (`tests/reconnaissance/`):
- Purpose: Exploration and discovery
- Pattern: Raw Playwright calls acceptable
- Temporary: Not maintained long-term
- Output: Spike reports and field catalogs

**Production Tests** (`tests/e2e/`):
- Purpose: Automated regression testing
- Pattern: MUST use page objects exclusively
- Permanent: Maintained as product evolves
- Output: Pass/fail results and artifacts

**Rule**: Reconnaissance findings must be refactored into page objects before production use.

---

## Dynamic Form Handling

**Constraint**: No selector fallbacks or retry logic - explicit waits only

**Playwright Wait Strategies**:
- **Lazy loading**: `locator.wait_for(state='visible')` - wait for element appearance
- **API-driven dropdowns**: `page.wait_for_response(url_pattern)` - wait for data fetch
- **SPA transitions**: `page.wait_for_load_state('networkidle')` - wait for route change
- **Conditional fields**: `x-depends-on` in specs defines prerequisite fields
- **Multi-step forms**: `x-form-steps` array defines navigation sequence
- **Iframe content**: `frame_locator().locator().wait_for()` - wait for nested elements

**Timeout Configuration**: Per-field via `x-timeout` in specifications (default 15s)
**Failure Mode**: Timeout exceptions with artifacts (screenshots, trace, HAR, telemetry)

---

## Environment Variables

**FORM_JSON**: JSON payload with form field values
```bash
export FORM_JSON='{"first_name":"Ada","last_name":"Lovelace","email":"ada@example.com","advisor_id":"A123456","policy":"PAR-00112233"}'
```

**SUBMIT**: Controls form submission (default: `false`)
```bash
export SUBMIT=true   # Actually submit form
export SUBMIT=false  # Dry-run: fill but don't submit
# Omit variable = dry-run mode
```

**Doppler Secrets**: Injected via `doppler run --project insurance --config prd`
- `MANULIFE_PAR_USERNAME` - Usage determined during reconnaissance
- `MANULIFE_PAR_PASSWORD` - Usage determined during reconnaissance

---

## AI Agent Brief

For any AI coding agent implementing form automation:

> **Environment**: Python + Playwright, auth via `storage-state.json`, secrets via Doppler
> **Input**: JSON payload in `FORM_JSON` env var
> **Artifacts**: Screenshots (PII-masked), DOM dumps, HAR, trace, telemetry NDJSON
> **No video recording**
> **Implementation**: ARIA-first selectors, explicit waits (no retry logic), fail-fast on errors
> **Submission**: Environment-controlled via `SUBMIT=true` flag
> **Output**: `artifacts/YYYY-MM-DD_HH-MM-SS/` with `index.json` manifest

**Full specification**: [`specifications/manulife-par-form.yaml`](/Users/terryli/own/insurance/specifications/manulife-par-form.yaml)

---

## Development Standards

**Python**: `uv run --active python -m <module>`
**Versioning**: SemVer 2.0.0
**Paths**: Always absolute (`/Users/terryli/...`), space after extension
**Security**: Doppler injection only, never commit secrets
**Machine-Readable**: OpenAPI 3.1.0 specs prioritized over human docs

---

## Project Structure

```
~/own/insurance/
â”œâ”€â”€ CLAUDE.md                           # Project hub (this file)
â”œâ”€â”€ pytest.ini                          # Pytest configuration
â”œâ”€â”€ .gitignore                          # Excludes secrets, artifacts, auth state
â”œâ”€â”€ .github/                            # GitHub configuration
â”‚   â””â”€â”€ ISSUE_TEMPLATE/
â”‚       â””â”€â”€ ai-review-request.yml      # HITL review issue template
â”œâ”€â”€ pages/                              # Page objects (OUTSIDE tests/)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_page.py                   # Base class with common methods
â”‚   â”œâ”€â”€ manulife_par_page.py          # Manulife Par form page object
â”‚   â””â”€â”€ components/                    # Reusable components
â”‚       â””â”€â”€ __init__.py
â”œâ”€â”€ tests/                              # Pytest test directory
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py                    # Shared fixtures (browser, page, artifacts)
â”‚   â”œâ”€â”€ reconnaissance/                # Exploratory discovery tests
â”‚   â”‚   â”œâ”€â”€ explore_welcome_page.py   # Welcome page exploration
â”‚   â”‚   â”œâ”€â”€ explore_full_form.py      # Full form exploration
â”‚   â”‚   â””â”€â”€ test_comprehensive_path_exploration.py  # 19 form variations (Phase 6)
â”‚   â”œâ”€â”€ automation/                    # Form automation tests
â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â””â”€â”€ e2e/                           # End-to-end tests
â”‚       â””â”€â”€ test_coverage_form_example.py
â”œâ”€â”€ utils/                              # Shared utilities
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ artifact_manager.py            # Centralized artifact capture
â”‚   â”œâ”€â”€ artifact_uploader.py          # Upload artifacts to GitHub artifacts branch
â”‚   â”œâ”€â”€ github_review.py              # GitHub Issues review workflow manager
â”‚   â””â”€â”€ approval_gate.py              # @require_approval decorator for HITL
â”œâ”€â”€ fixtures/                           # Test data
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ auth/                               # Authentication
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ passkey_authenticator.py      # Reusable auth module
â”‚   â””â”€â”€ archive/                       # Archived scripts from Phase 0
â”‚       â”œâ”€â”€ final_auth.py             # Original auth script
â”‚       â”œâ”€â”€ reconnaissance.py         # Original reconnaissance
â”‚       â””â”€â”€ README.md                 # Migration guide
â”œâ”€â”€ docs/                               # Documentation
â”‚   â”œâ”€â”€ INDEX.md                       # Documentation hub
â”‚   â”œâ”€â”€ AUDIT.md                       # Playwright API verification (v1.1.0)
â”‚   â”œâ”€â”€ architecture/                  # Architecture docs
â”‚   â”‚   â”œâ”€â”€ page-object-design.md     # POM design patterns (v1.0.0)
â”‚   â”‚   â””â”€â”€ test-strategy.md          # 3-phase strategy (v1.0.0)
â”‚   â”œâ”€â”€ automation/                    # Automation workflows
â”‚   â”‚   â””â”€â”€ manulife-par.md           # Manulife Par form automation
â”‚   â”œâ”€â”€ analysis/                      # Technical analysis
â”‚   â”‚   â”œâ”€â”€ custom-react-components-spike.md  # Custom component solution
â”‚   â”‚   â”œâ”€â”€ manulife-par-field-catalog.md     # Field inventory (v1.0.0)
â”‚   â”‚   â””â”€â”€ phase-6-exploration-analysis.md   # Phase 6 findings
â”‚   â”œâ”€â”€ decisions/                     # Technology evaluations
â”‚   â”‚   â””â”€â”€ stagehand-evaluation.md   # Stagehand framework analysis (v1.0.0)
â”‚   â”œâ”€â”€ research/                      # Deep-dive reference docs
â”‚   â”‚   â”œâ”€â”€ cdp-webauthn-reference.md # CDP WebAuthn API (v1.0.0)
â”‚   â”‚   â””â”€â”€ cdp-webauthn-quick-reference.md
â”‚   â””â”€â”€ workflows/                     # Operational workflows
â”‚       â”œâ”€â”€ authentication-implementation.md  # Passkey auth (v1.0.0)
â”‚       â”œâ”€â”€ credential-sync.md        # Doppler sync workflow
â”‚       â””â”€â”€ human-in-the-loop-review.md      # HITL review workflow (v1.0.0)
â”œâ”€â”€ specifications/                     # Machine-readable specs
â”‚   â”œâ”€â”€ playwright-automation.yaml    # Universal automation spec
â”‚   â”œâ”€â”€ manulife-par-form.yaml       # Main form specification
â”‚   â”œâ”€â”€ slo.yaml                      # Service level objectives
â”‚   â””â”€â”€ pages/                         # Page-level specs (modular)
â”‚       â””â”€â”€ welcome-page.yaml         # Welcome page spec (v1.0.0)
â”œâ”€â”€ scripts/                            # Scripts
â”‚   â”œâ”€â”€ hooks/                         # Git hooks
â”‚   â”œâ”€â”€ playwright/                    # Playwright utilities
â”‚   â””â”€â”€ setup/                         # Setup scripts
â”œâ”€â”€ artifacts/                         # Generated artifacts (gitignored)
â”‚   â””â”€â”€ .gitkeep
â””â”€â”€ storage-state.json                 # Playwright auth state (gitignored)
```

---

## Playwright Feature Requirements

Specifications define required Playwright capabilities:

- [x] **Tracing**: screenshots + DOM snapshots via `BrowserContext.tracing.start()`
- [x] **HAR recording**: Network capture via `Browser.new_context(record_har=...)`
- [x] **PII-safe screenshots**: Mask sensitive fields via `Page.screenshot(mask=[...])`
- [x] **ARIA-first selectors**: `getByLabel/Role/Placeholder` priority
- [x] **ARIA snapshots**: Accessibility tree via `Locator.aria_snapshot()` (YAML)
- [x] **Iframe handling**: `FrameLocator` for nested forms
- [x] **Network telemetry**: `request/response/requestfailed` events logged
- [x] **Console capture**: JS errors and logs via `console/pageerror` events
- [x] **Offline replay**: `routeFromHAR` for analysis
- [x] **File upload**: `setInputFiles` for PDF/documents
- [x] **Wait strategies**: `wait_for_load_state`, `wait_for_response`, `locator.wait_for`
- [x] **No video recording**: Performance/PII concerns

**API Verification**: [`docs/AUDIT.md`](/Users/terryli/own/insurance/docs/AUDIT.md) v1.1.0 (11/11 APIs confirmed)
**Specifications**: [`specifications/playwright-automation.yaml`](/Users/terryli/own/insurance/specifications/playwright-automation.yaml) `x-implementation-requirements`

---

## Global Resources

**Parent Config**: [`~/.claude/CLAUDE.md`](/Users/terryli/.claude/CLAUDE.md)
**Doppler Integration**: [`~/.claude/specifications/doppler-integration.yaml`](/Users/terryli/.claude/specifications/doppler-integration.yaml)
**Toolchain**: [`~/.claude/docs/setup/toolchain.md`](/Users/terryli/.claude/docs/setup/toolchain.md)
**Credential Management**: [`~/.claude/docs/setup/credential-management.md`](/Users/terryli/.claude/docs/setup/credential-management.md)
