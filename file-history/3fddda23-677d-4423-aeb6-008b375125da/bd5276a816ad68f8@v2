"""
Stateful STL decomposition for production ML features

Implements causal STL feature generation using fit/transform pattern:
- fit(): Decompose training data, store seasonal pattern
- transform(): Apply stored pattern to new data (no temporal leakage)

SLOs:
- Correctness: Seasonal pattern alignment error < 1e-10 (numerical precision)
- Availability: No data length restrictions beyond 2*period minimum
- Observability: Logs fit operations, raises on invalid state
- Maintainability: Single class, statsmodels dependency only

Dependencies: statsmodels>=0.14.0
"""

import pickle
from pathlib import Path
from typing import Optional, Dict, Any
import pandas as pd
import numpy as np
from statsmodels.tsa.seasonal import STL


class StatefulSTLAtoms:
    """
    Stateful STL feature generator for causal ML features

    Pattern:
    1. fit(train_df): Decompose with STL, store seasonal pattern
    2. transform(new_df): Align stored pattern, compute trend causally

    Guarantees:
    - No future data usage (causal)
    - Deterministic alignment (time-index based)
    - Reversible decomposition (trend + seasonal + resid = original)
    """

    def __init__(self, seasonal: int, trend: int):
        """
        Args:
            seasonal: Seasonal smoothing parameter (must be odd)
            trend: Trend smoothing parameter (must be odd, > seasonal)

        Raises:
            ValueError: If parameters invalid
        """
        if seasonal % 2 == 0 or trend % 2 == 0:
            raise ValueError(f"seasonal={seasonal} and trend={trend} must be odd")
        if trend <= seasonal:
            raise ValueError(f"trend={trend} must be > seasonal={seasonal}")

        self.seasonal = seasonal
        self.trend = trend
        self.period = seasonal

        self.seasonal_pattern = None
        self.fitted_index_start = None
        self.bar_duration = None
        self.is_fitted = False

    def fit(self, df: pd.DataFrame) -> 'StatefulSTLAtoms':
        """
        Fit STL on training data

        Args:
            df: DataFrame with 'close' column and datetime index

        Returns:
            self

        Raises:
            ValueError: If missing 'close' column or insufficient data
        """
        if 'close' not in df.columns:
            raise ValueError("DataFrame missing required 'close' column")

        if len(df) < 2 * self.period:
            raise ValueError(
                f"Insufficient data: need >={2 * self.period} rows, got {len(df)}"
            )

        # Fit STL
        stl = STL(
            df['close'],
            period=self.period,
            seasonal=self.seasonal,
            trend=self.trend
        )
        result = stl.fit()

        # Store seasonal pattern (last full cycle)
        self.seasonal_pattern = result.seasonal.iloc[-self.period:].values

        # Store time index metadata
        self.fitted_index_start = df.index[0]
        if len(df) > 1:
            self.bar_duration = (df.index[1] - df.index[0]).total_seconds()
        else:
            self.bar_duration = None

        self.is_fitted = True

        return self

    def transform(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Transform data using fitted STL parameters

        Args:
            df: DataFrame with 'close' column and datetime index

        Returns:
            DataFrame with: stl_trend, stl_seasonal, stl_resid

        Raises:
            ValueError: If not fitted or missing 'close' column
        """
        if not self.is_fitted:
            raise ValueError("Must call fit() before transform()")

        if 'close' not in df.columns:
            raise ValueError("DataFrame missing required 'close' column")

        # Align seasonal pattern with new time index
        seasonal_component = self._align_seasonal_pattern(df)

        # Deseasonalize
        deseasonalized = df['close'].values - seasonal_component

        # Compute causal trend (EWM on deseasonalized)
        trend_component = pd.Series(deseasonalized).ewm(
            span=self.trend,
            adjust=False
        ).mean().values

        # Residual
        residual_component = (
            df['close'].values - trend_component - seasonal_component
        )

        return pd.DataFrame({
            'stl_trend': trend_component,
            'stl_seasonal': seasonal_component,
            'stl_resid': residual_component
        }, index=df.index)

    def _align_seasonal_pattern(self, df: pd.DataFrame) -> np.ndarray:
        """
        Align stored seasonal pattern with new data's time index

        Algorithm (from sktime Deseasonalizer):
        1. Calculate time shift in bars
        2. Roll pattern by shift % period
        3. Tile to match new data length

        Args:
            df: DataFrame with datetime index

        Returns:
            Aligned seasonal component (length = len(df))
        """
        n = len(df)

        if self.bar_duration is None or n == 0:
            # Fallback: simple tiling
            return np.tile(self.seasonal_pattern, n // self.period + 1)[:n]

        # Calculate shift in number of bars
        time_diff = (df.index[0] - self.fitted_index_start).total_seconds()
        bars_elapsed = int(time_diff / self.bar_duration)

        # Roll and tile
        shift = bars_elapsed % self.period
        aligned_pattern = np.roll(self.seasonal_pattern, -shift)
        aligned_seasonal = np.tile(aligned_pattern, n // self.period + 1)[:n]

        return aligned_seasonal

    def save(self, filepath: str):
        """
        Serialize fitted model to disk

        Args:
            filepath: Output pickle path

        Raises:
            ValueError: If model not fitted
        """
        if not self.is_fitted:
            raise ValueError("Cannot save unfitted model")

        filepath = Path(filepath)
        filepath.parent.mkdir(parents=True, exist_ok=True)

        with open(filepath, 'wb') as f:
            pickle.dump(self, f)

    @classmethod
    def load(cls, filepath: str) -> 'StatefulSTLAtoms':
        """
        Deserialize fitted model from disk

        Args:
            filepath: Input pickle path

        Returns:
            Loaded StatefulSTLAtoms instance

        Raises:
            FileNotFoundError: If file doesn't exist
            TypeError: If loaded object wrong type
        """
        with open(filepath, 'rb') as f:
            model = pickle.load(f)

        if not isinstance(model, cls):
            raise TypeError(f"Loaded object type {type(model)}, expected {cls}")

        return model
