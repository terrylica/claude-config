"""
OKX Price Provider API with Parquet-backed candle cache.

This module provides point-in-time price lookups from cached OHLC candles:
- Fast in-memory price lookups (< 1ms per query)
- Forward-fill for missing timestamps
- Returns close price by default (or OHLC if needed)
- Symbol normalization (BTC → BTC-USDT)
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional

import numpy as np
import pandas as pd

from .cache import ParquetVWAPCache
from .utils import normalize_symbol, denormalize_symbol

logger = logging.getLogger(__name__)


class OKXPriceProvider:
    """
    Fast point-in-time price lookup API backed by Parquet-cached candles.

    This class loads OHLC candles from Parquet cache into memory and provides
    O(1) price lookups with forward-fill for missing timestamps.

    Features:
    - Sub-millisecond price lookups
    - Returns close price by default
    - Automatic forward-fill for missing timestamps
    - Symbol normalization (BTC → BTC-USDT)
    - Batch queries for efficiency
    - Lazy loading (only loads data when first accessed)

    Attributes:
        cache_file: Path to Parquet cache
        market_type: "spot" or "swap"
        candles_df: In-memory candles DataFrame (loaded on first use)

    Examples:
        >>> # Initialize provider
        >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
        >>>
        >>> # Get single price (close price at timestamp)
        >>> btc_price = provider.get_price(
        ...     symbol="BTC",
        ...     timestamp=pd.Timestamp("2023-10-01 08:00:00", tz="UTC")
        ... )
        >>> print(f"BTC: ${btc_price:,.2f}")
        >>>
        >>> # Get multiple prices (faster than repeated get_price)
        >>> prices = provider.get_prices(
        ...     symbols=["BTC", "ETH", "SOL"],
        ...     timestamp=pd.Timestamp("2023-10-01 08:00:00", tz="UTC")
        ... )
        >>> for symbol, price in prices.items():
        ...     print(f"{symbol}: ${price:,.2f}")
    """

    def __init__(
        self,
        cache_dir: Path,
        market_type: str = "spot",
        cache_filename: str = "candles_4h.parquet",
        preload: bool = False,
    ):
        """
        Initialize price provider.

        Args:
            cache_dir: Directory containing Parquet cache
            market_type: "spot" or "swap"
            cache_filename: Name of Parquet cache file (default: candles_4h.parquet)
            preload: If True, load cache immediately; if False, lazy load on first query

        Raises:
            FileNotFoundError: If cache file doesn't exist (when preload=True)
        """
        self.cache_file = Path(cache_dir) / cache_filename
        self.market_type = market_type
        self.candles_df = None

        logger.info(
            f"Initialized OKXPriceProvider: cache={self.cache_file}, "
            f"market={market_type}, preload={preload}"
        )

        if preload:
            self._load_cache()

    def _load_cache(self) -> None:
        """
        Load candle cache into memory and build index.

        This method is called automatically on first price query if not preloaded.
        """
        if self.candles_df is not None:
            logger.debug("Cache already loaded, skipping")
            return

        if not self.cache_file.exists():
            raise FileNotFoundError(f"Cache file not found: {self.cache_file}")

        logger.info("Loading candle cache into memory...")

        # Load from Parquet
        self.candles_df = pd.read_parquet(self.cache_file)

        # Build multi-index for O(1) lookups
        self.candles_df = self.candles_df.set_index(["timestamp", "symbol"]).sort_index()

        logger.info(
            f"Loaded {len(self.candles_df):,} candles, "
            f"{self.candles_df.index.get_level_values('symbol').nunique()} unique symbols"
        )

    def get_price(
        self,
        symbol: str,
        timestamp: pd.Timestamp,
        price_type: str = "close",
        fill_method: str = "ffill",
        raise_on_missing: bool = False,
    ) -> float:
        """
        Get price for symbol at timestamp.

        Args:
            symbol: Symbol (e.g., "BTC", "ETH") - will be normalized to BTC-USDT
            timestamp: Timestamp to query (must be timezone-aware UTC)
            price_type: Price to return: "close", "open", "high", "low", or "vwap"
                - "close": Close price (default)
                - "vwap": (H+L+C)/3 approximation
            fill_method: How to handle missing data:
                - "ffill": Forward-fill (use most recent available price)
                - "none": Return NaN if missing
            raise_on_missing: If True, raise ValueError when no data available

        Returns:
            Price (float)

        Raises:
            ValueError: If symbol not found and raise_on_missing=True
            FileNotFoundError: If cache not loaded yet

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>>
            >>> # Get close price at exact timestamp
            >>> price = provider.get_price("BTC", pd.Timestamp("2023-10-01 08:00:00", tz="UTC"))
            >>>
            >>> # Get VWAP approximation
            >>> vwap = provider.get_price("BTC", pd.Timestamp("2023-10-01 08:00:00", tz="UTC"), price_type="vwap")
        """
        # Lazy load cache if not already loaded
        if self.candles_df is None:
            self._load_cache()

        # Normalize symbol (BTC → BTC-USDT)
        norm_symbol = self._normalize_symbol_internal(symbol)

        # Ensure timestamp is timezone-aware
        if timestamp.tz is None:
            timestamp = timestamp.tz_localize("UTC")

        try:
            # Try exact lookup first (O(1) with multi-index)
            candle = self.candles_df.loc[(timestamp, norm_symbol)]

            if price_type == "vwap":
                # VWAP approximation: (H+L+C)/3
                return float((candle["high"] + candle["low"] + candle["close"]) / 3)
            else:
                return float(candle[price_type])

        except KeyError:
            # Exact timestamp+symbol not found
            if fill_method == "ffill":
                return self._forward_fill(norm_symbol, timestamp, price_type, raise_on_missing)
            elif fill_method == "none":
                if raise_on_missing:
                    raise ValueError(
                        f"No price data for {symbol} at {timestamp} (exact match)"
                    )
                return np.nan
            else:
                raise ValueError(f"Unknown fill_method: {fill_method}")

    def _forward_fill(
        self, norm_symbol: str, timestamp: pd.Timestamp, price_type: str, raise_on_missing: bool
    ) -> float:
        """
        Forward-fill price (use most recent available price before timestamp).

        Args:
            norm_symbol: Normalized symbol (e.g., "BTC-USDT")
            timestamp: Query timestamp
            price_type: Price type to return ("close", "open", "high", "low", "vwap")
            raise_on_missing: Raise error if no data available

        Returns:
            Forward-filled price

        Raises:
            ValueError: If no price data available before timestamp
        """
        # Filter to this symbol and timestamps <= query timestamp
        mask = (
            self.candles_df.index.get_level_values("symbol") == norm_symbol
        ) & (self.candles_df.index.get_level_values("timestamp") <= timestamp)

        subset = self.candles_df[mask]

        if subset.empty:
            base_symbol = denormalize_symbol(norm_symbol)
            if raise_on_missing:
                raise ValueError(
                    f"No price data for {base_symbol} at or before {timestamp}"
                )
            logger.warning(f"No data for {base_symbol} at or before {timestamp}, returning NaN")
            return np.nan

        # Get most recent candle (last row)
        latest_candle = subset.iloc[-1]
        latest_timestamp = subset.index[-1][0]

        # Extract requested price
        if price_type == "vwap":
            latest_price = float((latest_candle["high"] + latest_candle["low"] + latest_candle["close"]) / 3)
        else:
            latest_price = float(latest_candle[price_type])

        # Log if forward-fill spans > 1 day (might indicate data gap)
        time_diff = (timestamp - latest_timestamp).total_seconds() / 3600  # hours
        if time_diff > 24:
            logger.warning(
                f"Forward-filling {denormalize_symbol(norm_symbol)} from "
                f"{latest_timestamp} to {timestamp} ({time_diff:.1f} hours gap)"
            )

        return latest_price

    def get_prices(
        self,
        symbols: List[str],
        timestamp: pd.Timestamp,
        price_type: str = "close",
        fill_method: str = "ffill",
        raise_on_missing: bool = False,
    ) -> Dict[str, float]:
        """
        Get prices for multiple symbols at timestamp (batch query).

        This is more efficient than calling get_price() repeatedly.

        Args:
            symbols: List of symbols (e.g., ["BTC", "ETH", "SOL"])
            timestamp: Timestamp to query
            price_type: Price to return ("close", "open", "high", "low", "vwap")
            fill_method: "ffill" or "none"
            raise_on_missing: Raise error if any symbol has no data

        Returns:
            Dict mapping symbol → price

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>>
            >>> prices = provider.get_prices(
            ...     symbols=["BTC", "ETH", "SOL"],
            ...     timestamp=pd.Timestamp("2023-10-01 08:00:00", tz="UTC")
            ... )
            >>> print(prices)
            {'BTC': 45000.0, 'ETH': 2500.0, 'SOL': 25.0}
        """
        # Lazy load cache if not already loaded
        if self.candles_df is None:
            self._load_cache()

        prices = {}

        for symbol in symbols:
            try:
                prices[symbol] = self.get_price(
                    symbol=symbol,
                    timestamp=timestamp,
                    price_type=price_type,
                    fill_method=fill_method,
                    raise_on_missing=raise_on_missing,
                )
            except ValueError as e:
                if raise_on_missing:
                    raise
                logger.warning(f"Failed to get price for {symbol}: {e}")
                prices[symbol] = np.nan

        return prices

    def get_price_series(
        self,
        symbol: str,
        start_date: pd.Timestamp,
        end_date: pd.Timestamp,
        price_type: str = "close"
    ) -> pd.Series:
        """
        Get time series of prices for a symbol over date range.

        Args:
            symbol: Symbol (e.g., "BTC")
            start_date: Start timestamp
            end_date: End timestamp
            price_type: Price to return ("close", "open", "high", "low", "vwap")

        Returns:
            Series with timestamp index and price values

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>>
            >>> btc_series = provider.get_price_series(
            ...     symbol="BTC",
            ...     start_date=pd.Timestamp("2023-10-01", tz="UTC"),
            ...     end_date=pd.Timestamp("2023-10-31", tz="UTC")
            ... )
            >>> print(btc_series.describe())
        """
        # Lazy load cache if not already loaded
        if self.candles_df is None:
            self._load_cache()

        # Normalize symbol
        norm_symbol = self._normalize_symbol_internal(symbol)

        # Filter to symbol and date range
        mask = (
            self.candles_df.index.get_level_values("symbol") == norm_symbol
        ) & (
            self.candles_df.index.get_level_values("timestamp") >= start_date
        ) & (
            self.candles_df.index.get_level_values("timestamp") <= end_date
        )

        subset = self.candles_df[mask]

        if subset.empty:
            logger.warning(f"No data for {symbol} between {start_date} and {end_date}")
            return pd.Series(dtype=float)

        # Extract timestamp and price as Series
        if price_type == "vwap":
            series = ((subset["high"] + subset["low"] + subset["close"]) / 3).copy()
        else:
            series = subset[price_type].copy()

        series.index = series.index.get_level_values("timestamp")

        return series

    def get_available_symbols(self) -> List[str]:
        """
        Get list of available symbols in cache.

        Returns:
            Sorted list of base symbols (e.g., ["BTC", "ETH", ...])

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>> symbols = provider.get_available_symbols()
            >>> print(f"Available: {', '.join(symbols[:10])}")
        """
        # Lazy load if needed
        if self.candles_df is None:
            self._load_cache()

        # Extract from loaded data
        norm_symbols = self.candles_df.index.get_level_values("symbol").unique()
        return sorted([denormalize_symbol(s) for s in norm_symbols])

    def get_date_range(self) -> tuple:
        """
        Get coverage date range (min and max timestamps in cache).

        Returns:
            Tuple of (start_timestamp, end_timestamp)

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>> start, end = provider.get_date_range()
            >>> print(f"Coverage: {start.date()} to {end.date()}")
        """
        # Lazy load if needed
        if self.candles_df is None:
            self._load_cache()

        # Extract from loaded data
        timestamps = self.candles_df.index.get_level_values("timestamp")
        return timestamps.min(), timestamps.max()

    def _normalize_symbol_internal(self, symbol: str) -> str:
        """
        Normalize symbol to OKX format (internal helper).

        Args:
            symbol: Raw symbol (e.g., "BTC")

        Returns:
            Normalized symbol (e.g., "BTC-USDT" for spot)
        """
        return normalize_symbol(symbol, market_type=self.market_type)

    def reload_cache(self) -> None:
        """
        Reload cache from Parquet (useful if cache was updated externally).

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>>
            >>> # ... use provider ...
            >>>
            >>> # Cache was updated externally, reload
            >>> provider.reload_cache()
        """
        logger.info("Reloading cache from Parquet")
        self.candles_df = None
        self._load_cache()

    def __repr__(self) -> str:
        """String representation."""
        if self.candles_df is None:
            status = "not loaded"
        else:
            status = f"{len(self.candles_df):,} candles loaded"

        return f"OKXPriceProvider(cache={self.cache_file}, market={self.market_type}, {status})"
