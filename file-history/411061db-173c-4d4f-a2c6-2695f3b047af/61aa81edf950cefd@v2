"""
OKX Price Provider API with Parquet-backed caching and forward-fill.

This module provides the main user-facing API for price lookups:
- Fast in-memory price lookups (< 1ms per query)
- Forward-fill for missing data
- Batch queries for efficiency
- Symbol normalization (BTC → BTC-USDT)
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional

import numpy as np
import pandas as pd

from .cache import ParquetVWAPCache
from .utils import normalize_symbol, denormalize_symbol

logger = logging.getLogger(__name__)


class OKXPriceProvider:
    """
    Fast price lookup API backed by Parquet-cached VWAP data.

    This class loads VWAP data from Parquet cache into memory and provides
    O(1) price lookups with forward-fill for missing data.

    Features:
    - Sub-millisecond price lookups
    - Automatic forward-fill for missing timestamps
    - Symbol normalization (BTC → BTC-USDT)
    - Batch queries for efficiency
    - Lazy loading (only loads data when first accessed)

    Attributes:
        cache: ParquetVWAPCache instance
        market_type: "spot" or "swap"
        vwap_df: In-memory VWAP DataFrame (loaded on first use)
        index: Multi-index (timestamp, symbol) for fast lookups

    Examples:
        >>> # Initialize provider
        >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
        >>>
        >>> # Get single price
        >>> btc_price = provider.get_price(
        ...     symbol="BTC",
        ...     timestamp=pd.Timestamp("2023-10-01 08:00:00", tz="UTC")
        ... )
        >>> print(f"BTC: ${btc_price:,.2f}")
        >>>
        >>> # Get multiple prices (faster than repeated get_price)
        >>> prices = provider.get_prices(
        ...     symbols=["BTC", "ETH", "SOL"],
        ...     timestamp=pd.Timestamp("2023-10-01 08:00:00", tz="UTC")
        ... )
        >>> for symbol, price in prices.items():
        ...     print(f"{symbol}: ${price:,.2f}")
    """

    def __init__(
        self,
        cache_dir: Path,
        market_type: str = "spot",
        cache_filename: str = "vwap_8h.parquet",
        preload: bool = False,
    ):
        """
        Initialize price provider.

        Args:
            cache_dir: Directory containing Parquet cache
            market_type: "spot" or "swap"
            cache_filename: Name of Parquet cache file
            preload: If True, load cache immediately; if False, lazy load on first query

        Raises:
            FileNotFoundError: If cache file doesn't exist (when preload=True)
        """
        self.cache = ParquetVWAPCache(cache_dir=cache_dir, cache_filename=cache_filename)
        self.market_type = market_type
        self.vwap_df = None
        self.index = None

        logger.info(
            f"Initialized OKXPriceProvider: cache={self.cache.cache_file}, "
            f"market={market_type}, preload={preload}"
        )

        if preload:
            self._load_cache()

    def _load_cache(self) -> None:
        """
        Load VWAP cache into memory and build index.

        This method is called automatically on first price query if not preloaded.
        """
        if self.vwap_df is not None:
            logger.debug("Cache already loaded, skipping")
            return

        logger.info("Loading VWAP cache into memory...")

        # Load from Parquet
        self.vwap_df = self.cache.load()

        # Build multi-index for O(1) lookups
        self.vwap_df = self.vwap_df.set_index(["timestamp", "symbol"]).sort_index()

        logger.info(
            f"Loaded {len(self.vwap_df):,} VWAP records, "
            f"{self.vwap_df.index.get_level_values('symbol').nunique()} unique symbols"
        )

    def get_price(
        self,
        symbol: str,
        timestamp: pd.Timestamp,
        fill_method: str = "ffill",
        raise_on_missing: bool = False,
    ) -> float:
        """
        Get VWAP price for symbol at timestamp.

        Args:
            symbol: Symbol (e.g., "BTC", "ETH") - will be normalized to BTC-USDT
            timestamp: Timestamp to query (must be timezone-aware UTC)
            fill_method: How to handle missing data:
                - "ffill": Forward-fill (use most recent available price)
                - "none": Return NaN if missing
            raise_on_missing: If True, raise ValueError when no data available

        Returns:
            VWAP price (float)

        Raises:
            ValueError: If symbol not found and raise_on_missing=True
            FileNotFoundError: If cache not loaded yet

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>>
            >>> # Get price at exact timestamp
            >>> price = provider.get_price("BTC", pd.Timestamp("2023-10-01 08:00:00", tz="UTC"))
            >>>
            >>> # Get price with forward-fill
            >>> price = provider.get_price("BTC", pd.Timestamp("2023-10-01 09:30:00", tz="UTC"))
        """
        # Lazy load cache if not already loaded
        if self.vwap_df is None:
            self._load_cache()

        # Normalize symbol (BTC → BTC-USDT)
        norm_symbol = self._normalize_symbol_internal(symbol)

        # Ensure timestamp is timezone-aware
        if timestamp.tz is None:
            timestamp = timestamp.tz_localize("UTC")

        try:
            # Try exact lookup first (O(1) with multi-index)
            return float(self.vwap_df.loc[(timestamp, norm_symbol), "vwap"])

        except KeyError:
            # Exact timestamp+symbol not found
            if fill_method == "ffill":
                return self._forward_fill(norm_symbol, timestamp, raise_on_missing)
            elif fill_method == "none":
                if raise_on_missing:
                    raise ValueError(
                        f"No price data for {symbol} at {timestamp} (exact match)"
                    )
                return np.nan
            else:
                raise ValueError(f"Unknown fill_method: {fill_method}")

    def _forward_fill(
        self, norm_symbol: str, timestamp: pd.Timestamp, raise_on_missing: bool
    ) -> float:
        """
        Forward-fill price (use most recent available price before timestamp).

        Args:
            norm_symbol: Normalized symbol (e.g., "BTC-USDT")
            timestamp: Query timestamp
            raise_on_missing: Raise error if no data available

        Returns:
            Forward-filled price

        Raises:
            ValueError: If no price data available before timestamp
        """
        # Filter to this symbol and timestamps <= query timestamp
        mask = (
            self.vwap_df.index.get_level_values("symbol") == norm_symbol
        ) & (self.vwap_df.index.get_level_values("timestamp") <= timestamp)

        subset = self.vwap_df[mask]

        if subset.empty:
            base_symbol = denormalize_symbol(norm_symbol)
            if raise_on_missing:
                raise ValueError(
                    f"No price data for {base_symbol} at or before {timestamp}"
                )
            logger.warning(f"No data for {base_symbol} at or before {timestamp}, returning NaN")
            return np.nan

        # Return most recent price (last row)
        latest_price = float(subset.iloc[-1]["vwap"])
        latest_timestamp = subset.index[-1][0]

        # Log if forward-fill spans > 1 day (might indicate data gap)
        time_diff = (timestamp - latest_timestamp).total_seconds() / 3600  # hours
        if time_diff > 24:
            logger.warning(
                f"Forward-filling {denormalize_symbol(norm_symbol)} from "
                f"{latest_timestamp} to {timestamp} ({time_diff:.1f} hours gap)"
            )

        return latest_price

    def get_prices(
        self,
        symbols: List[str],
        timestamp: pd.Timestamp,
        fill_method: str = "ffill",
        raise_on_missing: bool = False,
    ) -> Dict[str, float]:
        """
        Get prices for multiple symbols at timestamp (batch query).

        This is more efficient than calling get_price() repeatedly.

        Args:
            symbols: List of symbols (e.g., ["BTC", "ETH", "SOL"])
            timestamp: Timestamp to query
            fill_method: "ffill" or "none"
            raise_on_missing: Raise error if any symbol has no data

        Returns:
            Dict mapping symbol → price

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>>
            >>> prices = provider.get_prices(
            ...     symbols=["BTC", "ETH", "SOL"],
            ...     timestamp=pd.Timestamp("2023-10-01 08:00:00", tz="UTC")
            ... )
            >>> print(prices)
            {'BTC': 45000.0, 'ETH': 2500.0, 'SOL': 25.0}
        """
        # Lazy load cache if not already loaded
        if self.vwap_df is None:
            self._load_cache()

        prices = {}

        for symbol in symbols:
            try:
                prices[symbol] = self.get_price(
                    symbol=symbol,
                    timestamp=timestamp,
                    fill_method=fill_method,
                    raise_on_missing=raise_on_missing,
                )
            except ValueError as e:
                if raise_on_missing:
                    raise
                logger.warning(f"Failed to get price for {symbol}: {e}")
                prices[symbol] = np.nan

        return prices

    def get_price_series(
        self, symbol: str, start_date: pd.Timestamp, end_date: pd.Timestamp
    ) -> pd.Series:
        """
        Get time series of prices for a symbol over date range.

        Args:
            symbol: Symbol (e.g., "BTC")
            start_date: Start timestamp
            end_date: End timestamp

        Returns:
            Series with timestamp index and price values

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>>
            >>> btc_series = provider.get_price_series(
            ...     symbol="BTC",
            ...     start_date=pd.Timestamp("2023-10-01", tz="UTC"),
            ...     end_date=pd.Timestamp("2023-10-31", tz="UTC")
            ... )
            >>> print(btc_series.describe())
        """
        # Lazy load cache if not already loaded
        if self.vwap_df is None:
            self._load_cache()

        # Normalize symbol
        norm_symbol = self._normalize_symbol_internal(symbol)

        # Filter to symbol and date range
        mask = (
            self.vwap_df.index.get_level_values("symbol") == norm_symbol
        ) & (
            self.vwap_df.index.get_level_values("timestamp") >= start_date
        ) & (
            self.vwap_df.index.get_level_values("timestamp") <= end_date
        )

        subset = self.vwap_df[mask]

        if subset.empty:
            logger.warning(f"No data for {symbol} between {start_date} and {end_date}")
            return pd.Series(dtype=float)

        # Extract timestamp and price as Series
        series = subset["vwap"].copy()
        series.index = series.index.get_level_values("timestamp")

        return series

    def get_available_symbols(self) -> List[str]:
        """
        Get list of available symbols in cache.

        Returns:
            Sorted list of base symbols (e.g., ["BTC", "ETH", ...])

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>> symbols = provider.get_available_symbols()
            >>> print(f"Available: {', '.join(symbols[:10])}")
        """
        if self.vwap_df is None:
            # Load from Parquet metadata (fast)
            return [denormalize_symbol(s) for s in self.cache.get_symbol_list()]
        else:
            # Extract from loaded data
            norm_symbols = self.vwap_df.index.get_level_values("symbol").unique()
            return sorted([denormalize_symbol(s) for s in norm_symbols])

    def get_date_range(self) -> tuple:
        """
        Get coverage date range (min and max timestamps in cache).

        Returns:
            Tuple of (start_timestamp, end_timestamp)

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>> start, end = provider.get_date_range()
            >>> print(f"Coverage: {start.date()} to {end.date()}")
        """
        if self.vwap_df is None:
            # Load from Parquet (doesn't load full data)
            return self.cache.get_date_range()
        else:
            # Extract from loaded data
            timestamps = self.vwap_df.index.get_level_values("timestamp")
            return timestamps.min(), timestamps.max()

    def _normalize_symbol_internal(self, symbol: str) -> str:
        """
        Normalize symbol to OKX format (internal helper).

        Args:
            symbol: Raw symbol (e.g., "BTC")

        Returns:
            Normalized symbol (e.g., "BTC-USDT" for spot)
        """
        return normalize_symbol(symbol, market_type=self.market_type)

    def reload_cache(self) -> None:
        """
        Reload cache from Parquet (useful if cache was updated externally).

        Examples:
            >>> provider = OKXPriceProvider(cache_dir=Path("data/okx_price_cache"))
            >>>
            >>> # ... use provider ...
            >>>
            >>> # Cache was updated externally, reload
            >>> provider.reload_cache()
        """
        logger.info("Reloading cache from Parquet")
        self.vwap_df = None
        self.index = None
        self._load_cache()

    def __repr__(self) -> str:
        """String representation."""
        if self.vwap_df is None:
            status = "not loaded"
        else:
            status = f"{len(self.vwap_df):,} records loaded"

        return f"OKXPriceProvider(cache={self.cache.cache_file}, market={self.market_type}, {status})"
