#!/usr/bin/env python3
"""
Download funding rates and tick data for November and December 2023.
"""

import sys
from pathlib import Path
import pandas as pd
import httpx
from io import BytesIO
from zipfile import ZipFile
from datetime import datetime, timedelta

sys.path.insert(0, str(Path(__file__).parent.parent / "libs" / "okx-price-provider" / "src"))

from okx_price_provider.cdn_downloader import download_month_ticks


def download_funding_rates_month(year, month):
    """Download funding rates for a month from OKX CDN."""
    print(f"\nDownloading funding rates for {year}-{month:02d}...")

    output_file = Path(f"data/funding_rates_{year}{month:02d}.parquet")
    if output_file.exists():
        print(f"✓ Already exists: {output_file}")
        return

    # Get all days in month
    start_date = datetime(year, month, 1)
    if month == 12:
        end_date = datetime(year + 1, 1, 1) - timedelta(days=1)
    else:
        end_date = datetime(year, month + 1, 1) - timedelta(days=1)

    all_rates = []

    for day in range(1, end_date.day + 1):
        url = f"https://www.okx.com/cdn/okex/traderecords/swaprate/monthly/{year}{month:02d}/allswaprate-swaprate-{year}-{month:02d}-{day:02d}.zip"

        try:
            print(f"  Downloading {year}-{month:02d}-{day:02d}...", end='', flush=True)

            resp = httpx.get(url, timeout=60, follow_redirects=True)
            resp.raise_for_status()

            with ZipFile(BytesIO(resp.content)) as zf:
                csv_name = [name for name in zf.namelist() if name.endswith('.csv')][0]
                with zf.open(csv_name) as csv_file:
                    # OKX uses GBK encoding with bilingual headers
                    df = pd.read_csv(csv_file, encoding='gbk')
                    # Normalize column names (remove Chinese)
                    df.columns = [col.split('/')[0] for col in df.columns]

                    all_rates.append(df)
                    print(f" {len(df):,} records")

        except Exception as e:
            print(f" ERROR: {e}")
            continue

    if not all_rates:
        print(f"ERROR: No data downloaded for {year}-{month:02d}")
        return

    # Combine and save
    combined = pd.concat(all_rates, ignore_index=True)

    # Create timestamp from funding_time (milliseconds)
    combined['timestamp'] = pd.to_datetime(combined['funding_time'], unit='ms', utc=True)

    # Keep only relevant columns (match October format)
    combined = combined[['timestamp', 'instrument_name', 'funding_rate', 'real_funding_rate']].copy()
    combined.rename(columns={'instrument_name': 'symbol'}, inplace=True)

    # Convert rates from strings to floats
    combined['funding_rate'] = pd.to_numeric(combined['funding_rate'], errors='coerce')
    combined['real_funding_rate'] = pd.to_numeric(combined['real_funding_rate'], errors='coerce')

    output_file.parent.mkdir(exist_ok=True)
    combined.to_parquet(output_file)

    print(f"✓ Saved {len(combined):,} funding rate records to {output_file}")


def main():
    """Download Nov and Dec 2023 data."""

    months = [
        (2023, 11),  # November
        (2023, 12),  # December
    ]

    print("="*80)
    print("Downloading November and December 2023 Data")
    print("="*80)

    # Download funding rates (small, fast)
    print("\n" + "="*80)
    print("STEP 1: Downloading Funding Rates")
    print("="*80)

    for year, month in months:
        download_funding_rates_month(year, month)

    # Download tick data (large, slow)
    print("\n" + "="*80)
    print("STEP 2: Downloading Tick Data")
    print("="*80)
    print("\nThis will download ~1.6 GB of data.")
    print("Continue? [y/N]: ", end='', flush=True)

    # Auto-confirm if running non-interactively
    if not sys.stdin.isatty():
        print("y (auto-confirmed)")
        proceed = True
    else:
        proceed = input().strip().lower() == 'y'

    if not proceed:
        print("\nSkipping tick data download.")
        return

    for year, month in months:
        output_file = Path(f"data/okx_ticks/{year}{month:02d}.parquet")

        if output_file.exists():
            size_mb = output_file.stat().st_size / 1024 / 1024
            print(f"\n✓ Already exists: {output_file} ({size_mb:.1f} MB)")
            continue

        print(f"\nDownloading tick data for {year}-{month:02d}...")

        output_file.parent.mkdir(exist_ok=True)

        # download_month_ticks writes directly to file
        download_month_ticks(
            msg_type="allspot",
            year=year,
            month=month,
            output_parquet=output_file
        )

        size_mb = output_file.stat().st_size / 1024 / 1024
        df = pd.read_parquet(output_file)
        print(f"✓ Saved {len(df):,} trades to {output_file} ({size_mb:.1f} MB)")

    print("\n" + "="*80)
    print("DOWNLOAD COMPLETE")
    print("="*80)


if __name__ == "__main__":
    main()
