"""
Utility functions for portfolio management.
"""

from typing import Dict


def validate_weights(weights: Dict[str, float], tolerance: float = 0.01) -> bool:
    """
    Validate that weights are valid.

    Args:
        weights: Dictionary of weights {symbol: weight}
        tolerance: Acceptable deviation from sum=1.0

    Returns:
        True if weights are valid

    Raises:
        ValueError: If weights are invalid
    """
    if not weights:
        raise ValueError("Weights dictionary cannot be empty")

    # Check for negative weights
    for symbol, weight in weights.items():
        if weight < 0:
            raise ValueError(f"Negative weight for {symbol}: {weight}")

    # Check sum
    total = sum(weights.values())
    if abs(total - 1.0) > tolerance:
        raise ValueError(
            f"Weights sum to {total:.4f}, expected 1.0 (Â±{tolerance})"
        )

    return True


def normalize_weights(weights: Dict[str, float]) -> Dict[str, float]:
    """
    Normalize weights to sum to 1.0.

    Args:
        weights: Dictionary of weights

    Returns:
        Normalized weights

    Raises:
        ValueError: If all weights are zero or negative
    """
    if not weights:
        return {}

    total = sum(weights.values())

    if total <= 0:
        raise ValueError(f"Cannot normalize: total weight is {total}")

    return {symbol: weight / total for symbol, weight in weights.items()}


def calculate_turnover(
    old_weights: Dict[str, float],
    new_weights: Dict[str, float]
) -> float:
    """
    Calculate portfolio turnover (L1 half-turnover).

    Args:
        old_weights: Previous portfolio weights
        new_weights: New portfolio weights

    Returns:
        Turnover as fraction (0.0 to 1.0)
    """
    all_symbols = set(old_weights.keys()) | set(new_weights.keys())

    total_change = sum(
        abs(new_weights.get(sym, 0.0) - old_weights.get(sym, 0.0))
        for sym in all_symbols
    )

    # Half-turnover (one-sided)
    return total_change / 2.0


def calculate_concentration(weights: Dict[str, float]) -> Dict[str, float]:
    """
    Calculate concentration metrics for portfolio.

    Args:
        weights: Portfolio weights

    Returns:
        Dictionary with concentration metrics
    """
    if not weights:
        return {
            "herfindahl_index": 0.0,
            "effective_n": 0.0,
            "max_weight": 0.0,
            "top3_concentration": 0.0
        }

    # Herfindahl-Hirschman Index (HHI)
    hhi = sum(w**2 for w in weights.values())

    # Effective number of positions
    effective_n = 1.0 / hhi if hhi > 0 else 0.0

    # Max weight
    max_weight = max(weights.values()) if weights else 0.0

    # Top 3 concentration
    sorted_weights = sorted(weights.values(), reverse=True)
    top3 = sum(sorted_weights[:3]) if len(sorted_weights) >= 3 else sum(sorted_weights)

    return {
        "herfindahl_index": hhi,
        "effective_n": effective_n,
        "max_weight": max_weight,
        "top3_concentration": top3,
        "n_positions": len(weights)
    }


def format_dollar(amount: float, decimals: int = 2) -> str:
    """
    Format dollar amount with commas and sign.

    Args:
        amount: Dollar amount
        decimals: Number of decimal places

    Returns:
        Formatted string (e.g., "$1,234.56" or "-$1,234.56")
    """
    sign = "" if amount >= 0 else "-"
    abs_amount = abs(amount)
    return f"{sign}${abs_amount:,.{decimals}f}"


def format_percent(value: float, decimals: int = 2) -> str:
    """
    Format percentage with sign.

    Args:
        value: Percentage value (0.15 = 15%)
        decimals: Number of decimal places

    Returns:
        Formatted string (e.g., "+15.00%" or "-15.00%")
    """
    sign = "+" if value >= 0 else ""
    return f"{sign}{value * 100:.{decimals}f}%"
