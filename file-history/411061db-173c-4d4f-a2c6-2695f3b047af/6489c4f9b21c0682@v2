#!/usr/bin/env python3
"""
Test CDN tick data downloader.

This script validates the new tick-level data approach:
1. Download 2 days of tick data from CDN
2. Save to Parquet with optimal schema
3. Test various query patterns
4. Validate resampling capabilities

Run with: uv run --active python test_cdn_ticks.py
"""

import logging
import sys
from pathlib import Path

import pandas as pd

# Add libs to path for testing
sys.path.insert(0, str(Path(__file__).parent.parent / "libs" / "okx-price-provider" / "src"))

from okx_price_provider.cdn_downloader import download_month_ticks

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)

logger = logging.getLogger(__name__)


def test_tick_download():
    """Test downloading tick data for 2 days."""
    print("\n" + "=" * 80)
    print("Test 1: Download 2 Days of Tick Data")
    print("=" * 80 + "\n")

    # Test with just BTC and ETH for speed
    test_symbols = ["BTC-USDT", "ETH-USDT"]
    cache_dir = Path("data/okx_ticks_test")
    output_file = cache_dir / "202310_sample.parquet"

    print(f"Downloading Oct 1-2, 2023 for {', '.join(test_symbols)}")
    print(f"Output: {output_file}\n")

    try:
        # Download just first 2 days by modifying the function
        # (We'll download the full month but this tests the pipeline)
        stats = download_month_ticks(
            msg_type="allspot",
            year=2023,
            month=10,
            output_parquet=output_file,
            symbols_filter=test_symbols,
            skip_errors=True,
        )

        print(f"\n{'=' * 80}")
        print("Download Statistics:")
        print(f"{'=' * 80}")
        print(f"Days succeeded:      {stats['days_succeeded']}")
        print(f"Days failed:         {stats['days_failed']}")
        print(f"Total trades:        {stats['total_trades']:,}")
        print(f"Unique symbols:      {stats['unique_symbols']}")
        print(f"Date range:          {stats['date_range'][0]} to {stats['date_range'][1]}")
        print(f"File size:           {stats['file_size_mb']:.2f} MB")
        print(f"{'=' * 80}\n")

        return output_file

    except Exception as e:
        print(f"\n{'=' * 80}")
        print("Download FAILED")
        print(f"{'=' * 80}")
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return None


def test_tick_queries(parquet_file: Path):
    """Test various query patterns on tick data."""
    print("\n" + "=" * 80)
    print("Test 2: Query Tick Data")
    print("=" * 80 + "\n")

    # Load tick data
    print("Loading tick data...")
    df = pd.read_parquet(parquet_file)

    print(f"Loaded {len(df):,} trades")
    print(f"Columns: {df.columns.tolist()}")
    print(f"Memory usage: {df.memory_usage(deep=True).sum() / 1024 / 1024:.2f} MB\n")

    # Test 2.1: Filter by symbol and time range
    print(f"{'=' * 80}")
    print("Test 2.1: Filter by Symbol and Time Range")
    print(f"{'=' * 80}\n")

    btc_oct1 = df[
        (df["symbol"] == "BTC-USDT") &
        (df["timestamp"] >= "2023-10-01") &
        (df["timestamp"] < "2023-10-02")
    ]

    print(f"BTC trades on Oct 1: {len(btc_oct1):,}")
    print(f"First trade: {btc_oct1.iloc[0]['timestamp']} @ ${btc_oct1.iloc[0]['price']:,.2f}")
    print(f"Last trade:  {btc_oct1.iloc[-1]['timestamp']} @ ${btc_oct1.iloc[-1]['price']:,.2f}\n")

    # Test 2.2: Resample to 1-minute candles
    print(f"{'=' * 80}")
    print("Test 2.2: Resample to 1-Minute OHLC Candles")
    print(f"{'=' * 80}\n")

    btc_1m = btc_oct1.set_index("timestamp").resample("1min").agg({
        "price": ["first", "max", "min", "last"],
        "size": "sum",
        "trade_value": "sum",
    })

    # Flatten column names
    btc_1m.columns = ["open", "high", "low", "close", "volume", "trade_value"]
    btc_1m = btc_1m.dropna()

    print(f"Generated {len(btc_1m)} 1-minute candles")
    print(f"\nFirst 5 candles:")
    print(btc_1m.head())

    # Test 2.3: Compute VWAP for different intervals
    print(f"\n{'=' * 80}")
    print("Test 2.3: Compute VWAP at Different Intervals")
    print(f"{'=' * 80}\n")

    for interval in ["1H", "4H", "8H"]:
        vwap = btc_oct1.set_index("timestamp").resample(interval).apply(
            lambda g: g["trade_value"].sum() / g["size"].sum() if g["size"].sum() > 0 else None
        )
        vwap = vwap.dropna()

        print(f"{interval} VWAP:")
        print(f"  Periods: {len(vwap)}")
        if len(vwap) > 0:
            print(f"  First:   {vwap.index[0]} = ${vwap.iloc[0]:,.2f}")
            print(f"  Mean:    ${vwap.mean():,.2f}")

    # Test 2.4: Check compression efficiency
    print(f"\n{'=' * 80}")
    print("Test 2.4: Storage Efficiency")
    print(f"{'=' * 80}\n")

    file_size_bytes = parquet_file.stat().st_size
    file_size_mb = file_size_bytes / 1024 / 1024

    # Estimate uncompressed size
    row_size = (
        8 +  # timestamp
        20 + # symbol (avg)
        8 +  # price
        8 +  # size
        4 +  # side
        8    # trade_value
    )
    uncompressed_mb = (len(df) * row_size) / 1024 / 1024

    compression_ratio = uncompressed_mb / file_size_mb

    print(f"Parquet file size:     {file_size_mb:.2f} MB")
    print(f"Estimated raw size:    {uncompressed_mb:.2f} MB")
    print(f"Compression ratio:     {compression_ratio:.1f}x")
    print(f"Bytes per trade:       {file_size_bytes / len(df):.1f} bytes")


def main():
    """Run all tests."""
    print("\n" + "=" * 80)
    print("OKX CDN Tick Data Downloader - Validation Tests")
    print("=" * 80)

    # Test 1: Download tick data
    parquet_file = test_tick_download()

    if parquet_file and parquet_file.exists():
        # Test 2: Query and resample
        test_tick_queries(parquet_file)

        print("\n" + "=" * 80)
        print("All Tests Passed!")
        print("=" * 80)
        print("\nNext steps:")
        print("1. Download full October 2023 for all symbols")
        print("2. Update provider to work with tick data")
        print("3. Integrate with V1.7 backtester")
    else:
        print("\n" + "=" * 80)
        print("Tests Failed - Download did not complete")
        print("=" * 80)


if __name__ == "__main__":
    main()
