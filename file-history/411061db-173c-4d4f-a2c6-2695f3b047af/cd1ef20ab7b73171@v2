#!/usr/bin/env python3
"""
Download funding rates and tick data for Q2-Q3 2025 (June, July, August).

This is for testing the strategy on more recent data (2025) vs historical Q4 2023.
"""

import sys
from pathlib import Path
import pandas as pd
import httpx
from io import BytesIO
from zipfile import ZipFile
from datetime import datetime, timedelta

sys.path.insert(0, str(Path(__file__).parent.parent / "libs" / "okx-price-provider" / "src"))

from okx_price_provider.cdn_downloader import download_month_ticks


def download_funding_rates_month(year, month):
    """Download funding rates for a month from OKX CDN."""
    print(f"\n{'='*80}")
    print(f"Downloading Funding Rates: {year}-{month:02d}")
    print('='*80)

    output_file = Path(f"data/funding_rates_{year}{month:02d}.parquet")
    if output_file.exists():
        print(f"✓ Already exists: {output_file}")
        return

    # Get all days in month
    start_date = datetime(year, month, 1)
    if month == 12:
        end_date = datetime(year + 1, 1, 1) - timedelta(days=1)
    else:
        end_date = datetime(year, month + 1, 1) - timedelta(days=1)

    all_rates = []

    for day in range(1, end_date.day + 1):
        url = f"https://www.okx.com/cdn/okex/traderecords/swaprate/monthly/{year}{month:02d}/allswaprate-swaprate-{year}-{month:02d}-{day:02d}.zip"

        try:
            print(f"  Downloading {year}-{month:02d}-{day:02d}...", end='', flush=True)

            resp = httpx.get(url, timeout=60, follow_redirects=True)
            resp.raise_for_status()

            with ZipFile(BytesIO(resp.content)) as zf:
                csv_name = [name for name in zf.namelist() if name.endswith('.csv')][0]
                with zf.open(csv_name) as csv_file:
                    # OKX uses GBK encoding with bilingual headers
                    df = pd.read_csv(csv_file, encoding='gbk')
                    # Normalize column names (remove Chinese)
                    df.columns = [col.split('/')[0] for col in df.columns]

                    all_rates.append(df)
                    print(f" {len(df):,} records")

        except Exception as e:
            print(f" ERROR: {e}")
            continue

    if not all_rates:
        print(f"ERROR: No data downloaded for {year}-{month:02d}")
        return

    # Combine and save
    combined = pd.concat(all_rates, ignore_index=True)

    # Create timestamp from funding_time (milliseconds)
    combined['timestamp'] = pd.to_datetime(combined['funding_time'], unit='ms', utc=True)

    # Keep only relevant columns (match Q4 2023 format)
    combined = combined[['timestamp', 'instrument_name', 'funding_rate', 'real_funding_rate']].copy()
    combined.rename(columns={'instrument_name': 'symbol'}, inplace=True)

    # Convert rates from strings to floats
    combined['funding_rate'] = pd.to_numeric(combined['funding_rate'], errors='coerce')
    combined['real_funding_rate'] = pd.to_numeric(combined['real_funding_rate'], errors='coerce')

    output_file.parent.mkdir(exist_ok=True)
    combined.to_parquet(output_file)

    print(f"✓ Saved {len(combined):,} funding rate records to {output_file}")


def main():
    """Download Q2-Q3 2025 data (June, July, August)."""

    months = [
        (2025, 6),   # June
        (2025, 7),   # July
        (2025, 8),   # August
    ]

    print("="*80)
    print("Downloading Q2-Q3 2025 Data (Jun, Jul, Aug)")
    print("="*80)
    print("\nNote: Testing on 2025 data to validate strategy on recent market conditions")
    print("      Settlement frequencies may have changed from 2023 (8h → 4h for some symbols)")

    # Download funding rates first (small, fast)
    print("\n" + "="*80)
    print("STEP 1: Downloading Funding Rates")
    print("="*80)

    for year, month in months:
        download_funding_rates_month(year, month)

    # Download tick data (large, slow)
    print("\n" + "="*80)
    print("STEP 2: Downloading Tick Data")
    print("="*80)
    print("\nThis will download ~2.5 GB of data. Continue? [y/N]: ", end='', flush=True)

    # Auto-confirm if running non-interactively
    import sys
    if not sys.stdin.isatty():
        print("y (auto-confirmed)")
        proceed = True
    else:
        proceed = input().strip().lower() == 'y'

    if not proceed:
        print("\nSkipping tick data download.")
        print("You can download later by running this script again.")
        return

    for year, month in months:
        output_file = Path(f"data/okx_ticks/{year}{month:02d}.parquet")

        if output_file.exists():
            size_mb = output_file.stat().st_size / 1024 / 1024
            print(f"\n✓ Already exists: {output_file} ({size_mb:.1f} MB)")
            continue

        print(f"\nDownloading tick data for {year}-{month:02d}...")

        output_file.parent.mkdir(exist_ok=True)

        # download_month_ticks writes directly to file
        download_month_ticks(
            msg_type="allspot",
            year=year,
            month=month,
            output_parquet=output_file
        )

        size_mb = output_file.stat().st_size / 1024 / 1024
        df = pd.read_parquet(output_file)
        print(f"✓ Saved {len(df):,} trades to {output_file} ({size_mb:.1f} MB)")

    print("\n" + "="*80)
    print("DOWNLOAD COMPLETE")
    print("="*80)

    # Summary
    print("\nData files:")
    for year, month in months:
        funding_file = Path(f"data/funding_rates_{year}{month:02d}.parquet")
        tick_file = Path(f"data/okx_ticks/{year}{month:02d}.parquet")

        if funding_file.exists():
            df = pd.read_parquet(funding_file)
            print(f"  Funding {year}-{month:02d}: {len(df):,} records")

        if tick_file.exists():
            df = pd.read_parquet(tick_file)
            size_mb = tick_file.stat().st_size / 1024 / 1024
            print(f"  Ticks   {year}-{month:02d}: {len(df):,} trades ({size_mb:.0f} MB)")


if __name__ == "__main__":
    main()
