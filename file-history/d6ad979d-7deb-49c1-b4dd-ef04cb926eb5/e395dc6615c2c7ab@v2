#!/usr/bin/env python3
"""
Automated passkey authentication for Manulife Par using Playwright Virtual Authenticator.

This script:
1. Extracts passkey credential from Doppler environment variables
2. Converts JWK format private key to PKCS#8 format
3. Creates a virtual authenticator via Chrome DevTools Protocol
4. Injects the passkey credential
5. Navigates to Manulife Par and triggers passkey authentication
6. Saves authenticated session to storage-state.json

Usage:
    doppler run --project insurance --config prd -- \\
      uv run --active python -m scripts.setup.automated_passkey_auth

Prerequisites:
    - Passkey data in Doppler (MANULIFE_PAR_PASSKEY_*)
    - Playwright 1.55.0+ installed
    - jwcrypto library installed
"""

import base64
import json
import os
import sys
from pathlib import Path

from jwcrypto import jwk
from playwright.sync_api import sync_playwright


def jwk_to_pkcs8_base64(jwk_base64: str) -> str:
    """
    Convert JWK format private key to PKCS#8 format (base64-encoded).

    Args:
        jwk_base64: Base64-encoded JWK JSON

    Returns:
        Base64-encoded PKCS#8 private key for CDP WebAuthn.addCredential
    """
    # Fix base64 padding if needed
    # Base64 strings must be divisible by 4, pad with '=' if not
    missing_padding = len(jwk_base64) % 4
    if missing_padding:
        jwk_base64 += '=' * (4 - missing_padding)

    # Decode base64 JWK
    jwk_json = base64.b64decode(jwk_base64).decode('utf-8')
    jwk_dict = json.loads(jwk_json)

    # Load into jwcrypto JWK object
    key = jwk.JWK(**jwk_dict)

    # Export to PKCS#8 PEM format
    pkcs8_pem = key.export_to_pem(private_key=True, password=None)

    # Extract base64 content from PEM (remove header/footer)
    # PEM format: -----BEGIN PRIVATE KEY-----\nbase64\n-----END PRIVATE KEY-----
    pem_lines = pkcs8_pem.decode('utf-8').strip().split('\n')
    pkcs8_base64 = ''.join(line for line in pem_lines
                           if not line.startswith('-----'))

    return pkcs8_base64


def main() -> int:
    """Execute automated passkey authentication."""
    print("Manulife Par Automated Passkey Authentication")
    print("=" * 50)

    # Configuration from environment
    project_root = Path(__file__).parent.parent.parent
    storage_state_path = project_root / "storage-state.json"
    manulife_url = os.getenv("MANULIFE_PAR_URL", "www.insurance.manulife.ca")

    # Ensure URL has protocol and path
    if not manulife_url.startswith(("http://", "https://")):
        manulife_url = f"https://{manulife_url}/dda"

    # Extract passkey data from Doppler
    passkey_credential_id_raw = os.getenv("MANULIFE_PAR_PASSKEY_CREDENTIAL_ID")
    passkey_rp_id = os.getenv("MANULIFE_PAR_PASSKEY_RP_ID")
    passkey_user_handle_raw = os.getenv("MANULIFE_PAR_PASSKEY_USER_HANDLE")
    passkey_private_key_jwk = os.getenv("MANULIFE_PAR_PASSKEY_PRIVATE_KEY")

    # Fix base64 padding for credentialId and userHandle
    # WebAuthn uses URL-safe base64 without padding, but CDP might expect standard base64 with padding
    def add_base64_padding(s: str) -> str:
        """Add base64 padding if needed."""
        missing_padding = len(s) % 4
        if missing_padding:
            return s + '=' * (4 - missing_padding)
        return s

    passkey_credential_id = add_base64_padding(passkey_credential_id_raw)
    passkey_user_handle = add_base64_padding(passkey_user_handle_raw)

    # Validate all passkey components present
    missing = []
    if not passkey_credential_id:
        missing.append("MANULIFE_PAR_PASSKEY_CREDENTIAL_ID")
    if not passkey_rp_id:
        missing.append("MANULIFE_PAR_PASSKEY_RP_ID")
    if not passkey_user_handle:
        missing.append("MANULIFE_PAR_PASSKEY_USER_HANDLE")
    if not passkey_private_key_jwk:
        missing.append("MANULIFE_PAR_PASSKEY_PRIVATE_KEY")

    if missing:
        print(f"ERROR: Missing Doppler secrets: {', '.join(missing)}", file=sys.stderr)
        print()
        print("Ensure passkey data is in Doppler:")
        print("  doppler secrets --project insurance --config prd | grep PASSKEY")
        return 1

    print(f"URL: {manulife_url}")
    print(f"RP ID: {passkey_rp_id}")
    print(f"Output: {storage_state_path}")
    print()

    try:
        # Convert JWK private key to PKCS#8 format
        print("Converting JWK private key to PKCS#8 format...")
        pkcs8_private_key = jwk_to_pkcs8_base64(passkey_private_key_jwk)
        print("✓ Key conversion complete")
        print()

        with sync_playwright() as p:
            # Launch browser
            print("Launching browser...")
            browser = p.chromium.launch(headless=False)  # Non-headless for debugging
            context = browser.new_context()
            page = context.new_page()

            # Get CDP session for WebAuthn commands
            print("Creating virtual authenticator...")
            cdp = context.new_cdp_session(page)

            # Enable WebAuthn domain
            cdp.send("WebAuthn.enable")

            # Add virtual authenticator
            result = cdp.send("WebAuthn.addVirtualAuthenticator", {
                "options": {
                    "protocol": "ctap2",
                    "ctap2Version": "ctap2_1",
                    "transport": "internal",
                    "hasResidentKey": True,
                    "hasUserVerification": True,
                    "automaticPresenceSimulation": True,
                    "isUserVerified": True
                }
            })
            authenticator_id = result["authenticatorId"]
            print(f"✓ Virtual authenticator created: {authenticator_id}")

            # Add passkey credential
            print("Adding passkey credential...")
            print(f"DEBUG: credentialId length: {len(passkey_credential_id)}")
            print(f"DEBUG: privateKey length: {len(pkcs8_private_key)}")
            print(f"DEBUG: userHandle length: {len(passkey_user_handle)}")
            print(f"DEBUG: rpId: {passkey_rp_id}")

            credential_params = {
                "authenticatorId": authenticator_id,
                "credential": {
                    "credentialId": passkey_credential_id,
                    "privateKey": pkcs8_private_key,
                    "rpId": passkey_rp_id,
                    "userHandle": passkey_user_handle,
                    "signCount": 0,
                    "isResidentCredential": True
                }
            }

            try:
                cdp.send("WebAuthn.addCredential", credential_params)
                print("✓ Passkey credential injected")
            except Exception as e:
                print(f"ERROR: Failed to add credential: {e}")
                print(f"DEBUG: Credential params: {json.dumps(credential_params, indent=2)}")
                raise
            print()

            # Navigate to Manulife
            print(f"Navigating to {manulife_url}...")
            page.goto(manulife_url, wait_until="networkidle", timeout=30000)

            # Check current URL
            current_url = page.url
            print(f"Current URL: {current_url}")
            print()

            # If redirected to login, look for passkey authentication trigger
            if "signin" in current_url.lower() or "login" in current_url.lower():
                print("Detected signin page. Looking for passkey authentication option...")

                # Wait a moment for page to fully load
                page.wait_for_timeout(2000)

                # Look for common passkey/WebAuthn triggers
                # Try different selectors that might trigger passkey auth
                passkey_triggers = [
                    "button:has-text('Passkey')",
                    "button:has-text('Sign in with passkey')",
                    "button:has-text('Use passkey')",
                    "[data-testid*='passkey']",
                    "[aria-label*='passkey' i]",
                    "button:has-text('Continue')",
                ]

                triggered = False
                for selector in passkey_triggers:
                    try:
                        element = page.locator(selector).first
                        if element.is_visible(timeout=1000):
                            print(f"Found passkey trigger: {selector}")
                            element.click()
                            triggered = True
                            break
                    except Exception:
                        continue

                if triggered:
                    print("Clicked passkey trigger. Waiting for authentication...")
                    # Wait for authentication to complete and redirect
                    page.wait_for_load_state("networkidle", timeout=15000)
                else:
                    print("No explicit passkey trigger found. WebAuthn may auto-trigger...")
                    print("Waiting for potential automatic passkey challenge...")
                    page.wait_for_timeout(5000)

                # Check if we successfully authenticated
                current_url = page.url
                print(f"Current URL after auth: {current_url}")
            else:
                print("Not on signin page, may already be authenticated")

            print()
            print("Waiting for final page load...")
            page.wait_for_load_state("networkidle", timeout=10000)

            # Check if we're still on login page
            current_url = page.url
            if "login" in current_url.lower() or "sign" in current_url.lower():
                print()
                print("WARNING: Still appears to be on login page")
                print(f"Current URL: {current_url}")
                print("Saving session anyway for manual verification...")
                print()

            # Save storage state
            print()
            print("Saving storage state...")
            context.storage_state(path=str(storage_state_path))

            print(f"✓ Session saved to: {storage_state_path}")
            print()
            print("Next steps:")
            print("1. Verify file exists: ls -la storage-state.json")
            print("2. Run reconnaissance: doppler run --project insurance --config prd -- \\")
            print("                        uv run --active python -m scripts.playwright.reconnaissance")

            browser.close()
            return 0

    except Exception as e:
        print(f"\nERROR: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
