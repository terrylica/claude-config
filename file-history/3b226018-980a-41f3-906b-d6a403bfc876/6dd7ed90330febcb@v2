# OOD Robust Trading Profit Roadmap

**Date**: 2025-10-01
**Goal**: OOD robust trading profit based on rolling window walk-forward analysis
**Status**: Gap analysis complete, implementation roadmap defined

---

## ğŸ¯ Executive Summary

### Current Alignment with Goal: 45% Ready

**Strengths (what you have)**:
- âœ… Temporal validation infrastructure (walk-forward CV, TimeSeriesSplit)
- âœ… Custom fitness engine with MFE/MAE trading metrics
- âœ… Microstructure features for high-frequency data
- âœ… Regime detection for market conditions (cycleness)
- âœ… Zero-magic-number principles
- âœ… Comprehensive roadmap docs for trading strategy

**Critical Gaps (what's missing)**:
- âŒ **Backtesting framework** (not installed, not implemented)
- âŒ **OOD robustness testing** (no distribution shift detection)
- âŒ **Trading profit metrics** (Sharpe, Sortino, PnL, drawdown)
- âŒ **Position sizing & risk management**
- âŒ **Transaction cost modeling**

---

## ğŸ“Š Current State Analysis

### âœ… ALIGNED WITH GOAL (Keep & Enhance)

#### 1. Core Infrastructure (core_lib/)
```
core_lib/
â”œâ”€â”€ validation/temporal_validation_utils.py   âœ… SOTA temporal patterns
â”œâ”€â”€ sync/data_source_manager.py               âœ… Data access
â”œâ”€â”€ constraints/market_constraints.py         âœ… Market enums
â””â”€â”€ utilities/                                 âœ… Shared utilities
```
**Status**: Production-ready
**Action**: Enhance with OOD detection utilities

#### 2. Walk-Forward Validation (validation/)
```
validation/
â”œâ”€â”€ walk_forward/
â”‚   â”œâ”€â”€ simple_multi_objective_demo.py        âœ… Rolling origin CV
â”‚   â””â”€â”€ complete_framework.py                 âœ… Comprehensive validation
â””â”€â”€ nested_cv/
    â”œâ”€â”€ nested_cv_temporal_slicing.py         âœ… Nested CV (1,879 lines)
    â””â”€â”€ convergence_monitor_integration.py    âœ… Convergence detection
```
**Status**: Production-ready for ML validation
**Gap**: Not integrated with trading profit metrics
**Action**: Add profit-based optimization to walk-forward loop

#### 3. Trading-Relevant Features (features/)
```
features/
â”œâ”€â”€ fitness/
â”‚   â””â”€â”€ fitness_engine.py                     âœ… MFE/MAE trading metrics
â”œâ”€â”€ microstructure/                           âœ… 5 SOTA modules
â””â”€â”€ cycleness/                                âœ… Regime detection MVP
```
**Status**: Excellent foundation
**Gap**: Fitness engine not integrated with backtesting
**Action**: Bridge fitness metrics to backtesting framework

#### 4. Data Pipeline (data_pipeline/)
```
data_pipeline/
â”œâ”€â”€ binance/                                  âœ… Binance collector
â””â”€â”€ gap_filling/                              âœ… 8 gap-filling scripts
```
**Status**: Production-ready
**Action**: Add regime labeling for OOD detection

---

### âš ï¸ UNCERTAIN VALUE (Review & Decide)

#### Research Experiments (docs/ideas_brewing/)
```
docs/ideas_brewing/
â”œâ”€â”€ multi_objective_mae_mfe_meta_features/
â”‚   â””â”€â”€ fail_fast/
â”‚       â”œâ”€â”€ realistic_market_simulation/      âš ï¸ Might be useful for OOD stress testing
â”‚       â”œâ”€â”€ direct_quality_measurement/       âš ï¸ Synthetic data quality (not trading)
â”‚       â”œâ”€â”€ sota_financial_ts_generators/     âš ï¸ Research, not production
â”‚       â””â”€â”€ training_optimization/            âš ï¸ GPU training experiments
â””â”€â”€ meta-features-cycleness/                  âš ï¸ Overlaps with features/cycleness/
```

**Status**: 29 Python files, all dated Sep 15 (stale, 2+ weeks old)
**Issues**:
1. **Synthetic data generation focus** - not aligned with real trading profit
2. **Quality measurement for generators** - academic exercise, not profit-focused
3. **Stale experiments** - haven't been touched since Sep 15

**Decision Matrix**:
| Component | Keep? | Reason |
|-----------|-------|--------|
| `realistic_market_simulation/` | **MAYBE** | Could generate stress scenarios for OOD testing |
| `direct_quality_measurement/` | **PRUNE** | Evaluates synthetic data, not trading performance |
| `sota_financial_ts_generators/` | **PRUNE** | Research dead end for trading profit goal |
| `training_optimization/` | **PRUNE** | GPU experiments, not trading-focused |
| `meta-features-cycleness/` | **PRUNE** | Superseded by features/cycleness/ |

**Recommendation**: Archive entire `docs/ideas_brewing/` to `archive/research_experiments/`

---

### âŒ CRITICAL GAPS (Must Build)

#### 1. Backtesting Framework
**Current**: MISSING (mentioned in CLAUDE.md but not installed or implemented)
**Required**:
```python
# Add to pyproject.toml dependencies
"backtesting>=0.3.3"  # User specified backtesting.py ONLY

# Implement wrapper
automation/
â””â”€â”€ backtesting/
    â”œâ”€â”€ backtest_engine.py           # Wrapper for backtesting.py
    â”œâ”€â”€ profit_metrics.py            # Sharpe, Sortino, Calmar, PnL
    â”œâ”€â”€ transaction_costs.py         # Slippage + fees model
    â””â”€â”€ walk_forward_backtest.py     # Integrate with validation/walk_forward/
```

**Priority**: CRITICAL (blocks trading profit goal)

#### 2. OOD Robustness Testing
**Current**: MISSING (no distribution shift detection)
**Required**:
```python
core_lib/ood/
â”œâ”€â”€ distribution_shift_detector.py   # KL divergence, Wasserstein distance
â”œâ”€â”€ regime_classifier.py             # Label market regimes (bull/bear/sideways/crash)
â”œâ”€â”€ ood_test_suite.py                # Systematic OOD stress tests
â””â”€â”€ robustness_metrics.py            # Performance degradation tracking
```

**Key Capabilities**:
- Detect when validation/test data diverges from training distribution
- Label time periods by regime using features/cycleness/
- Test model performance across different regimes
- Track performance degradation as market conditions shift

**Priority**: CRITICAL (core to OOD robust goal)

#### 3. Trading Profit Metrics
**Current**: fitness_engine has MFE/MAE but not integrated
**Required**:
```python
automation/backtesting/profit_metrics.py:
- Sharpe Ratio
- Sortino Ratio
- Calmar Ratio
- Max Drawdown
- Win Rate
- Profit Factor
- Expectancy
- Recovery Factor
- Ulcer Index
```

**Priority**: CRITICAL (need profit-based optimization, not just MAE/RMSE)

#### 4. Position Sizing & Risk Management
**Current**: MISSING
**Required**:
```python
automation/trading/
â”œâ”€â”€ position_sizer.py                # Kelly, fixed fraction, volatility-based
â”œâ”€â”€ risk_manager.py                  # Stop-loss, take-profit, portfolio limits
â””â”€â”€ execution_simulator.py           # Order filling simulation
```

**Priority**: HIGH (prevents unrealistic backtest results)

#### 5. Transaction Cost Modeling
**Current**: MISSING
**Required**:
```python
automation/backtesting/transaction_costs.py:
- Maker/taker fees (Binance: 0.1% taker, 0.075% maker with BNB)
- Slippage model (market impact)
- Spread costs
- Realistic order fills
```

**Priority**: HIGH (critical for realistic profit estimation)

---

## ğŸ—‘ï¸ PRUNE Strategy

### Phase 1: Archive Stale Research (Immediate)

```bash
# Archive entire ideas_brewing directory
git mv docs/ideas_brewing/ archive/research_experiments/ideas_brewing/

# Keep only potentially useful market simulation
git mv archive/research_experiments/ideas_brewing/multi_objective_mae_mfe_meta_features/fail_fast/realistic_market_simulation/ \
    core_lib/ood/market_simulation/

# Document what was archived
```

**Disk space freed**: ~500KB Python code
**Benefit**: Clean workspace, clear focus on trading profit goal

### Phase 2: Remove Dead Library Integration Docs

```bash
# Move library experiments to archive unless actively used
docs/roadmap/lib_*.md  # Review each:
- lib_backtesting.md   â†’ Keep if exists
- lib_shap.md          â†’ Archive (not trading-focused)
- lib_darts.md         â†’ Archive (research, not used)
- lib_river.md         â†’ Archive (online learning, not immediate need)
- lib_tsai.md          â†’ Archive
- lib_tabpfn_ts.md     â†’ Archive (research)
```

### Phase 3: Consolidate Documentation

```bash
# Keep only trading-relevant roadmaps
docs/roadmap/
â”œâ”€â”€ parameterless_adaptive_trading_strategy.md  âœ… KEEP (core strategy)
â”œâ”€â”€ rolling_origin_framework.md                 âœ… KEEP (walk-forward)
â”œâ”€â”€ principles_and_compliance.md                âœ… KEEP (zero-magic-number)
â”œâ”€â”€ custom_fitness_research.md                  âœ… KEEP (trading fitness)
â””â”€â”€ technical_implementation.md                 âœ… KEEP (implementation guide)

# Archive rest to docs/archive/research_roadmaps/
```

---

## ğŸŒ± GROW Strategy

### Phase 1: Critical Trading Infrastructure (Week 1)

#### 1.1 Install & Setup Backtesting Framework
```bash
# Add to pyproject.toml
[project.dependencies]
+ "backtesting>=0.3.3",

# Install
uv add backtesting

# Create wrapper structure
mkdir -p automation/backtesting
mkdir -p automation/trading
```

#### 1.2 Implement Core Backtesting Engine
```python
# automation/backtesting/backtest_engine.py
"""
Wrapper for backtesting.py library integrated with walk-forward validation
"""
from backtesting import Backtest, Strategy
from typing import Dict, List
import pandas as pd

class WalkForwardBacktest:
    """
    Walk-forward backtesting with proper temporal splits

    Integrates:
    - validation/walk_forward/ for CV splits
    - features/fitness/fitness_engine.py for signal generation
    - Transaction costs and slippage modeling
    """

    def __init__(
        self,
        data: pd.DataFrame,
        strategy: Strategy,
        cv_config: dict,
        transaction_costs: dict = None
    ):
        self.data = data
        self.strategy = strategy
        self.cv_config = cv_config
        self.transaction_costs = transaction_costs or {
            'maker_fee': 0.00075,  # Binance with BNB
            'taker_fee': 0.001,
            'slippage_pct': 0.0005
        }

    def run_walk_forward(self) -> Dict:
        """Run walk-forward backtest with temporal integrity"""
        # Use TimeSeriesSplit from core_lib.validation
        # Return profit metrics for each fold
        pass
```

#### 1.3 Implement Profit Metrics Module
```python
# automation/backtesting/profit_metrics.py
"""
Trading profit metrics for walk-forward optimization
"""

def calculate_sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.0) -> float:
    """Annual Sharpe Ratio"""
    excess_returns = returns - risk_free_rate
    return np.sqrt(252) * excess_returns.mean() / excess_returns.std()

def calculate_sortino_ratio(returns: pd.Series, risk_free_rate: float = 0.0) -> float:
    """Annual Sortino Ratio (downside deviation only)"""
    excess_returns = returns - risk_free_rate
    downside_returns = returns[returns < 0]
    downside_std = downside_returns.std()
    return np.sqrt(252) * excess_returns.mean() / downside_std

def calculate_max_drawdown(equity_curve: pd.Series) -> float:
    """Maximum drawdown percentage"""
    cummax = equity_curve.cummax()
    drawdown = (equity_curve - cummax) / cummax
    return drawdown.min()

def calculate_calmar_ratio(returns: pd.Series) -> float:
    """Annual return / max drawdown"""
    annual_return = (1 + returns.mean()) ** 252 - 1
    max_dd = calculate_max_drawdown((1 + returns).cumprod())
    return annual_return / abs(max_dd)

# ... more metrics
```

**Deliverable**: Working backtesting framework integrated with walk-forward CV

---

### Phase 2: OOD Robustness Testing (Week 2)

#### 2.1 Distribution Shift Detection
```python
# core_lib/ood/distribution_shift_detector.py
"""
Detect when test/validation distribution diverges from training
"""
from scipy.stats import ks_2samp, wasserstein_distance
import numpy as np

class DistributionShiftDetector:
    """
    Detect distribution shifts using multiple methods
    """

    def __init__(self, significance_level: float = 0.05):
        self.significance_level = significance_level

    def detect_shift_ks_test(
        self,
        train_features: np.ndarray,
        test_features: np.ndarray
    ) -> Dict:
        """
        Kolmogorov-Smirnov test for distribution shift

        Returns:
            {
                'shift_detected': bool,
                'p_value': float,
                'statistic': float,
                'features_shifted': List[int]  # Which features shifted
            }
        """
        n_features = train_features.shape[1]
        shifted_features = []

        for i in range(n_features):
            statistic, p_value = ks_2samp(train_features[:, i], test_features[:, i])
            if p_value < self.significance_level:
                shifted_features.append(i)

        return {
            'shift_detected': len(shifted_features) > 0,
            'n_shifted_features': len(shifted_features),
            'features_shifted': shifted_features
        }

    def detect_shift_wasserstein(
        self,
        train_features: np.ndarray,
        test_features: np.ndarray,
        threshold: float = 0.1
    ) -> Dict:
        """Wasserstein distance for distribution shift"""
        distances = []
        for i in range(train_features.shape[1]):
            dist = wasserstein_distance(train_features[:, i], test_features[:, i])
            distances.append(dist)

        mean_distance = np.mean(distances)
        return {
            'shift_detected': mean_distance > threshold,
            'mean_distance': mean_distance,
            'per_feature_distances': distances
        }
```

#### 2.2 Regime Classification for OOD Testing
```python
# core_lib/ood/regime_classifier.py
"""
Classify market regimes for OOD robustness testing
"""

class MarketRegimeClassifier:
    """
    Label time periods by market regime

    Regimes:
    - Bull: Trending up, low volatility
    - Bear: Trending down, low volatility
    - Sideways: No trend, low volatility
    - High Volatility: Any trend, high volatility
    - Crash: Sharp drop, extreme volatility
    """

    def __init__(self, lookback_window: int = 60):
        self.lookback_window = lookback_window

    def classify_regimes(self, ohlcv: pd.DataFrame) -> pd.Series:
        """
        Classify each time period into regime

        Uses features/cycleness/ for change point detection
        Uses features/microstructure/ for volatility
        """
        # Calculate trend (SMA slope)
        # Calculate volatility (realized variance)
        # Detect crashes (bipower variation spikes)
        # Return regime labels
        pass

    def split_by_regime(
        self,
        data: pd.DataFrame,
        regimes: pd.Series
    ) -> Dict[str, pd.DataFrame]:
        """Split data by regime for OOD testing"""
        return {
            regime: data[regimes == regime]
            for regime in regimes.unique()
        }
```

#### 2.3 OOD Test Suite
```python
# core_lib/ood/ood_test_suite.py
"""
Systematic OOD robustness testing framework
"""

class OODTestSuite:
    """
    Test model performance under distribution shift
    """

    def run_regime_conditional_test(
        self,
        model,
        train_data: pd.DataFrame,
        test_data: pd.DataFrame,
        backtest_engine: WalkForwardBacktest
    ) -> Dict:
        """
        Test performance on each market regime separately

        Returns:
            {
                'bull_sharpe': float,
                'bear_sharpe': float,
                'sideways_sharpe': float,
                'crash_sharpe': float,
                'overall_sharpe': float,
                'regime_consistency': float  # Std dev of regime Sharpes
            }
        """
        pass

    def run_temporal_holdout_test(
        self,
        model,
        data: pd.DataFrame,
        n_holdout_periods: int = 5
    ) -> Dict:
        """
        Hold out recent time periods for OOD testing

        Train on older data, test on progressively newer data
        Track performance degradation over time
        """
        pass

    def run_stress_test(
        self,
        model,
        data: pd.DataFrame,
        stress_scenarios: List[str]
    ) -> Dict:
        """
        Test on specific stress scenarios

        Scenarios:
        - 2020 COVID crash
        - 2022 bear market
        - 2021 bull run
        - Flash crashes
        - Low liquidity periods
        """
        pass
```

**Deliverable**: Comprehensive OOD testing infrastructure

---

### Phase 3: Integration & Optimization (Week 3)

#### 3.1 Integrate Fitness Engine with Backtesting
```python
# automation/trading/fitness_based_strategy.py
"""
Trading strategy using fitness_engine for signals
"""
from features.fitness.fitness_engine import CustomFitnessEngine
from backtesting import Strategy

class FitnessBasedStrategy(Strategy):
    """
    Backtesting.py strategy using CustomFitnessEngine

    Integrates:
    - features/fitness/fitness_engine.py for MFE/MAE signals
    - features/microstructure/ for entry features
    - automation/trading/position_sizer.py for sizing
    - automation/trading/risk_manager.py for exits
    """

    # Use fitness signals to generate entry/exit signals
    # Apply position sizing
    # Apply risk management
    pass
```

#### 3.2 Walk-Forward Optimization with Profit Metrics
```python
# automation/optimization/walk_forward_optimizer.py
"""
Optimize strategy parameters using walk-forward with profit metrics
"""

class WalkForwardOptimizer:
    """
    Optimize using profit metrics (Sharpe) instead of prediction metrics (MAE)
    """

    def optimize_for_profit(
        self,
        strategy_class,
        data: pd.DataFrame,
        param_grid: Dict,
        cv_config: Dict,
        objective: str = 'sharpe_ratio'
    ) -> Dict:
        """
        Walk-forward optimization with profit objective

        Different from ML optimization:
        - Objective is Sharpe ratio, not MAE
        - Includes transaction costs
        - Tests on OOD regimes
        - Returns trading performance, not prediction accuracy
        """
        # Use TimeSeriesSplit
        # For each fold:
        #   - Optimize params on train using grid search
        #   - Backtest on test with transaction costs
        #   - Calculate Sharpe ratio
        # Return params with best average Sharpe
        pass
```

#### 3.3 End-to-End Pipeline
```python
# automation/pipelines/ood_robust_trading_pipeline.py
"""
Complete pipeline from data â†’ features â†’ backtest â†’ OOD validation â†’ profit
"""

class OODRobustTradingPipeline:
    """
    End-to-end pipeline for OOD robust trading profit

    Steps:
    1. Collect data (data_pipeline/)
    2. Generate features (features/)
    3. Train model with walk-forward CV (validation/)
    4. Backtest with transaction costs (automation/backtesting/)
    5. Test OOD robustness (core_lib/ood/)
    6. Calculate profit metrics (automation/backtesting/profit_metrics.py)
    7. Generate report with regime-conditional performance
    """

    def run_full_pipeline(
        self,
        symbol: str = "SOLUSDT",
        interval: str = "15m",
        start_date: str = "2022-09-10",
        end_date: str = "2025-08-31"
    ) -> Dict:
        """Run complete OOD robust trading profit pipeline"""
        # 1. Data collection
        # 2. Feature generation
        # 3. Regime labeling
        # 4. Walk-forward backtest
        # 5. OOD testing
        # 6. Profit analysis
        pass
```

**Deliverable**: Complete automated pipeline from data to OOD-validated profit

---

## ğŸ“‹ Implementation Timeline

### Week 1: Critical Trading Infrastructure
**Days 1-2**: Install backtesting.py, create wrapper
**Days 3-4**: Implement profit metrics module
**Day 5**: Test basic walk-forward backtest
**Deliverable**: Working backtesting with Sharpe/Sortino/Calmar

### Week 2: OOD Robustness Testing
**Days 1-2**: Distribution shift detector
**Days 3-4**: Regime classifier using cycleness features
**Day 5**: OOD test suite implementation
**Deliverable**: Regime-conditional performance testing

### Week 3: Integration & Optimization
**Days 1-2**: Integrate fitness_engine with backtesting
**Days 3-4**: Walk-forward profit optimization
**Day 5**: End-to-end pipeline
**Deliverable**: Complete OOD robust trading pipeline

### Week 4: Validation & Documentation
**Days 1-3**: Run full pipeline on SOLUSDT 3-year data
**Day 4**: Generate comprehensive performance report
**Day 5**: Documentation and examples
**Deliverable**: Production-ready OOD robust trading system

---

## ğŸ¯ Success Criteria

### Must-Have (CRITICAL)
- [ ] Backtesting framework installed and integrated with walk-forward CV
- [ ] Trading profit metrics (Sharpe, Sortino, Calmar, Max DD) calculated
- [ ] Transaction costs properly modeled
- [ ] OOD distribution shift detection working
- [ ] Regime-conditional backtesting implemented
- [ ] Performance tested across bull/bear/sideways/crash regimes

### Should-Have (HIGH PRIORITY)
- [ ] Position sizing system (Kelly, fixed fraction, volatility-based)
- [ ] Risk management (stop-loss, take-profit)
- [ ] Walk-forward optimization using Sharpe (not MAE)
- [ ] Fitness engine integrated with backtesting signals
- [ ] End-to-end pipeline automated

### Nice-to-Have (MEDIUM PRIORITY)
- [ ] Performance attribution analysis
- [ ] Trade execution simulation (realistic fills)
- [ ] Drawdown analysis and recovery tracking
- [ ] Feature importance for profit (SHAP on trades)

---

## ğŸš¨ Critical Decisions Needed

### 1. Archive or Repurpose ideas_brewing/?
**Question**: Should we archive entire `docs/ideas_brewing/` or extract useful parts?

**Options**:
- **Option A (Recommended)**: Archive entire directory, start fresh with trading focus
- **Option B**: Extract `realistic_market_simulation/` for OOD stress testing, archive rest
- **Option C**: Keep all for reference (clutters workspace)

**Recommendation**: **Option B** - Extract market simulation for OOD, archive rest

### 2. Which Backtesting Library?
**Question**: Stick with backtesting.py or explore alternatives?

**Options**:
- **backtesting.py** (your specification): Simple, fast, good for prototyping
- **vectorbt**: More powerful, GPU-accelerated, complex
- **bt**: More mature, institutional-grade, harder to learn

**Recommendation**: **backtesting.py** (per CLAUDE.md specification)

### 3. OOD Testing Approach?
**Question**: How rigorous should OOD testing be?

**Options**:
- **Light**: Just regime-conditional performance (bull/bear/sideways)
- **Medium (Recommended)**: Regime + distribution shift detection + temporal holdout
- **Heavy**: Above + stress scenarios + adversarial examples

**Recommendation**: **Medium** - Balances rigor with implementation time

---

## ğŸ“ Recommended Final Structure

```
ml-feature-experiments/
â”œâ”€â”€ core_lib/                        # Core utilities
â”‚   â”œâ”€â”€ sync/                        # Data access
â”‚   â”œâ”€â”€ validation/                  # Temporal validation patterns
â”‚   â”œâ”€â”€ constraints/                 # Market enums
â”‚   â”œâ”€â”€ utilities/                   # Shared utilities
â”‚   â””â”€â”€ ood/                         # ğŸ†• OOD testing utilities
â”‚       â”œâ”€â”€ distribution_shift_detector.py
â”‚       â”œâ”€â”€ regime_classifier.py
â”‚       â”œâ”€â”€ ood_test_suite.py
â”‚       â””â”€â”€ market_simulation/       # Extracted from ideas_brewing
â”œâ”€â”€ data_pipeline/                   # Data collection
â”‚   â”œâ”€â”€ binance/
â”‚   â””â”€â”€ gap_filling/
â”œâ”€â”€ features/                        # Feature engineering
â”‚   â”œâ”€â”€ microstructure/              # SOTA microstructure
â”‚   â”œâ”€â”€ cycleness/                   # Regime detection
â”‚   â””â”€â”€ fitness/                     # Trading fitness metrics
â”œâ”€â”€ validation/                      # ML validation
â”‚   â”œâ”€â”€ nested_cv/
â”‚   â””â”€â”€ walk_forward/
â”œâ”€â”€ automation/                      # ğŸ†• Trading automation
â”‚   â”œâ”€â”€ backtesting/                 # Backtesting framework
â”‚   â”‚   â”œâ”€â”€ backtest_engine.py
â”‚   â”‚   â”œâ”€â”€ profit_metrics.py
â”‚   â”‚   â”œâ”€â”€ transaction_costs.py
â”‚   â”‚   â””â”€â”€ walk_forward_backtest.py
â”‚   â”œâ”€â”€ trading/                     # Trading logic
â”‚   â”‚   â”œâ”€â”€ fitness_based_strategy.py
â”‚   â”‚   â”œâ”€â”€ position_sizer.py
â”‚   â”‚   â”œâ”€â”€ risk_manager.py
â”‚   â”‚   â””â”€â”€ execution_simulator.py
â”‚   â”œâ”€â”€ optimization/                # Strategy optimization
â”‚   â”‚   â””â”€â”€ walk_forward_optimizer.py
â”‚   â””â”€â”€ pipelines/                   # End-to-end pipelines
â”‚       â””â”€â”€ ood_robust_trading_pipeline.py
â”œâ”€â”€ experiments/                     # Active trading experiments
â”œâ”€â”€ examples/                        # Usage examples
â”‚   â”œâ”€â”€ 01_basic_backtest.py
â”‚   â”œâ”€â”€ 02_walk_forward_optimization.py
â”‚   â”œâ”€â”€ 03_ood_robustness_test.py
â”‚   â””â”€â”€ 04_full_pipeline.py
â”œâ”€â”€ archive/                         # Archived code
â”‚   â”œâ”€â”€ dead_code/
â”‚   â”œâ”€â”€ failed_experiments/
â”‚   â”œâ”€â”€ data_collection_legacy/
â”‚   â””â”€â”€ research_experiments/        # ğŸ†• Archived ideas_brewing
â”‚       â””â”€â”€ ideas_brewing/
â””â”€â”€ docs/                            # Documentation
    â”œâ”€â”€ roadmap/                     # Keep trading-focused roadmaps only
    â””â”€â”€ archive/                     # ğŸ†• Archived research roadmaps
```

---

## ğŸš€ Quick Start (After Implementation)

### Example 1: Basic Backtest
```python
from automation.backtesting.backtest_engine import WalkForwardBacktest
from automation.trading.fitness_based_strategy import FitnessBasedStrategy
from data_pipeline.binance.binance_public_data_collector import collect_data

# 1. Collect data
data = collect_data(symbol="SOLUSDT", interval="15m", start="2022-09-10", end="2025-08-31")

# 2. Create strategy using fitness signals
strategy = FitnessBasedStrategy

# 3. Run walk-forward backtest
backtest = WalkForwardBacktest(
    data=data,
    strategy=strategy,
    cv_config={'n_splits': 5, 'test_size': 90, 'gap': 7}
)

results = backtest.run_walk_forward()
print(f"Sharpe Ratio: {results['sharpe_ratio']:.2f}")
print(f"Max Drawdown: {results['max_drawdown']:.2%}")
print(f"Win Rate: {results['win_rate']:.2%}")
```

### Example 2: OOD Robustness Test
```python
from core_lib.ood.ood_test_suite import OODTestSuite
from core_lib.ood.regime_classifier import MarketRegimeClassifier

# 1. Classify regimes
classifier = MarketRegimeClassifier()
regimes = classifier.classify_regimes(data)

# 2. Run regime-conditional test
ood_suite = OODTestSuite()
ood_results = ood_suite.run_regime_conditional_test(
    model=strategy,
    train_data=train_data,
    test_data=test_data,
    backtest_engine=backtest
)

print("Performance by Regime:")
print(f"  Bull:     Sharpe = {ood_results['bull_sharpe']:.2f}")
print(f"  Bear:     Sharpe = {ood_results['bear_sharpe']:.2f}")
print(f"  Sideways: Sharpe = {ood_results['sideways_sharpe']:.2f}")
print(f"  Crash:    Sharpe = {ood_results['crash_sharpe']:.2f}")
print(f"Regime Consistency: {ood_results['regime_consistency']:.2f} (lower = more robust)")
```

### Example 3: Full Pipeline
```python
from automation.pipelines.ood_robust_trading_pipeline import OODRobustTradingPipeline

# Run complete pipeline
pipeline = OODRobustTradingPipeline()
results = pipeline.run_full_pipeline(
    symbol="SOLUSDT",
    interval="15m",
    start_date="2022-09-10",
    end_date="2025-08-31"
)

# Results include:
# - Walk-forward backtest performance
# - OOD robustness scores
# - Regime-conditional Sharpes
# - Transaction cost impact
# - Detailed trade log
```

---

## ğŸ“š References

### Implemented Patterns
- CLAUDE.md: "backtesting.py ONLY" - followed
- Temporal validation utils: TimeSeriesSplit, Pipeline, walk-forward CV
- Zero-magic-number principles: Data-driven parameters
- Custom fitness: MFE/MAE trading metrics

### Roadmap Docs (Keep)
- `docs/roadmap/parameterless_adaptive_trading_strategy.md` - Full trading system design
- `docs/roadmap/rolling_origin_framework.md` - Walk-forward methodology
- `docs/roadmap/custom_fitness_research.md` - Trading fitness background

### Academic References
- **Prado (2018)**: "Advances in Financial Machine Learning" - Chapter 7 (Cross-Validation), Chapter 12 (Backtesting)
- **Bailey et al. (2014)**: "The Probability of Backtest Overfitting" - Walk-forward validation
- **Lopez de Prado (2015)**: "The Future of Empirical Finance" - Combinatorial purged CV

---

**Status**: Ready for implementation
**Next Step**: Review and approve prune/grow decisions, then begin Week 1 implementation

