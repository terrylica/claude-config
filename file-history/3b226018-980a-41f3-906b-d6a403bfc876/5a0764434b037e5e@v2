#!/usr/bin/env python3
"""
Production-Ready Stateful STL Implementation

This module provides a stateful STL feature generator that can:
1. Fit once on historical data
2. Transform streaming/new data efficiently
3. Save/load fitted models
4. Handle time index alignment automatically

Usage:
    # Training phase
    stl = StatefulSTLAtoms(seasonal=13, trend=31)
    stl.fit(historical_df)
    stl.save('stl_model.pkl')

    # Production phase
    stl = StatefulSTLAtoms.load('stl_model.pkl')
    features = stl.transform(new_bar_df)  # Fast!
"""

import pickle
from pathlib import Path
from typing import Optional, Dict, Any
import pandas as pd
import numpy as np
from statsmodels.tsa.seasonal import STL


class StatefulSTLAtoms:
    """
    Stateful STL feature generator for production deployment

    This class fits STL decomposition on historical data and efficiently
    applies the learned seasonal pattern to new streaming data.

    Key Features:
    - Fit once on historical data (slow)
    - Transform many times on new data (fast)
    - Automatic time index alignment
    - Save/load functionality
    - Production-ready error handling

    Methodology:
    1. fit(): Decompose training data with STL, store seasonal pattern
    2. transform(): Align stored pattern with new data, compute trend causally
    3. Time alignment: Calculate time shift, roll seasonal pattern accordingly

    Example:
        # Training
        stl = StatefulSTLAtoms(seasonal=13, trend=31)
        stl.fit(train_df)
        stl.save('models/stl_13_31.pkl')

        # Production
        stl = StatefulSTLAtoms.load('models/stl_13_31.pkl')
        for new_bar in streaming_bars:
            features = stl.transform(new_bar)
            # features has: stl_trend, stl_seasonal, stl_resid
    """

    def __init__(self, seasonal: int = 13, trend: int = 31):
        """
        Initialize stateful STL feature generator

        Args:
            seasonal: Seasonal smoothing parameter (must be odd)
            trend: Trend smoothing parameter (must be odd, > seasonal)

        Raises:
            ValueError: If parameters are invalid
        """
        if seasonal % 2 == 0 or trend % 2 == 0:
            raise ValueError("seasonal and trend must be odd numbers")
        if trend <= seasonal:
            raise ValueError("trend must be greater than seasonal")

        self.seasonal = seasonal
        self.trend = trend
        self.period = seasonal

        # Fitted state (set during fit())
        self.seasonal_pattern = None
        self.fitted_index_start = None
        self.bar_duration = None
        self.is_fitted = False

    def fit(self, df: pd.DataFrame) -> 'StatefulSTLAtoms':
        """
        Fit STL on historical data

        This method:
        1. Decomposes historical data with STL
        2. Extracts and stores seasonal pattern (one full cycle)
        3. Records time index information for future alignment

        Args:
            df: Training DataFrame with 'close' column and datetime index

        Returns:
            self (for method chaining)

        Raises:
            ValueError: If insufficient data or missing columns
        """
        # Validate input
        if 'close' not in df.columns:
            raise ValueError("DataFrame must have 'close' column")

        if len(df) < 2 * self.period:
            raise ValueError(
                f"Need at least {2 * self.period} observations for seasonal={self.period}, "
                f"got {len(df)}"
            )

        # Fit STL on training data
        stl = STL(
            df['close'],
            period=self.period,
            seasonal=self.seasonal,
            trend=self.trend
        )
        result = stl.fit()

        # Store seasonal pattern (last full cycle)
        self.seasonal_pattern = result.seasonal.iloc[-self.period:].values

        # Store time index info for alignment
        self.fitted_index_start = df.index[0]
        if len(df) > 1:
            self.bar_duration = (df.index[1] - df.index[0]).total_seconds()
        else:
            self.bar_duration = None

        self.is_fitted = True

        print(f"✓ Fitted STL on {len(df)} observations")
        print(f"  Seasonal period: {self.period}")
        print(f"  Seasonal pattern range: [{self.seasonal_pattern.min():.4f}, {self.seasonal_pattern.max():.4f}]")
        print(f"  Fitted index start: {self.fitted_index_start}")

        return self

    def transform(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Transform new data using fitted STL parameters

        This method:
        1. Aligns stored seasonal pattern with new time index
        2. Deseasonalizes the new data
        3. Computes trend causally on deseasonalized data
        4. Calculates residual

        Args:
            df: New DataFrame with 'close' column and datetime index

        Returns:
            DataFrame with columns: stl_trend, stl_seasonal, stl_resid

        Raises:
            ValueError: If not fitted or missing columns
        """
        if not self.is_fitted:
            raise ValueError("Must call fit() before transform()")

        if 'close' not in df.columns:
            raise ValueError("DataFrame must have 'close' column")

        n = len(df)

        # Align seasonal pattern with new time index
        seasonal_component = self._align_seasonal_pattern(df)

        # Deseasonalize
        deseasonalized = df['close'].values - seasonal_component

        # Compute trend causally on deseasonalized data (using EWM)
        trend_component = self._compute_trend_causal(deseasonalized)

        # Residual
        residual_component = df['close'].values - trend_component - seasonal_component

        return pd.DataFrame({
            'stl_trend': trend_component,
            'stl_seasonal': seasonal_component,
            'stl_resid': residual_component
        }, index=df.index)

    def _align_seasonal_pattern(self, df: pd.DataFrame) -> np.ndarray:
        """
        Align stored seasonal pattern with new data's time index

        This implements the sktime Deseasonalizer approach:
        1. Calculate time shift between fitted data and new data
        2. Roll seasonal pattern by the shift amount
        3. Tile pattern to match new data length

        Args:
            df: New DataFrame with datetime index

        Returns:
            Aligned seasonal component (numpy array)
        """
        n = len(df)

        if self.bar_duration is None or n == 0:
            # Fallback: simple tiling without time-aware alignment
            return np.tile(self.seasonal_pattern, n // self.period + 1)[:n]

        # Calculate time shift (in number of bars)
        time_diff = (df.index[0] - self.fitted_index_start).total_seconds()
        bars_elapsed = int(time_diff / self.bar_duration)

        # Calculate shift within seasonal cycle
        shift = bars_elapsed % self.period

        # Roll and tile pattern
        aligned_pattern = np.roll(self.seasonal_pattern, -shift)
        aligned_seasonal = np.tile(aligned_pattern, n // self.period + 1)[:n]

        return aligned_seasonal

    def _compute_trend_causal(self, deseasonalized_data: np.ndarray) -> np.ndarray:
        """
        Compute trend causally on deseasonalized data

        Uses exponentially weighted moving average (EWM) for causal trend estimation.
        EWM is causal because it only uses past observations.

        Args:
            deseasonalized_data: Deseasonalized values (numpy array)

        Returns:
            Causal trend component (numpy array)
        """
        span = self.trend
        trend = pd.Series(deseasonalized_data).ewm(span=span, adjust=False).mean().values
        return trend

    def save(self, filepath: str):
        """
        Save fitted model to disk

        Args:
            filepath: Path to save pickle file

        Raises:
            ValueError: If model not fitted
        """
        if not self.is_fitted:
            raise ValueError("Cannot save unfitted model. Call fit() first.")

        filepath = Path(filepath)
        filepath.parent.mkdir(parents=True, exist_ok=True)

        with open(filepath, 'wb') as f:
            pickle.dump(self, f)

        print(f"✓ Saved model to {filepath}")

    @classmethod
    def load(cls, filepath: str) -> 'StatefulSTLAtoms':
        """
        Load fitted model from disk

        Args:
            filepath: Path to pickle file

        Returns:
            Loaded StatefulSTLAtoms instance

        Raises:
            FileNotFoundError: If file doesn't exist
        """
        with open(filepath, 'rb') as f:
            model = pickle.load(f)

        if not isinstance(model, cls):
            raise TypeError(f"Loaded object is not {cls.__name__}")

        print(f"✓ Loaded model from {filepath}")
        return model

    def get_params(self) -> Dict[str, Any]:
        """Get model parameters"""
        return {
            'seasonal': self.seasonal,
            'trend': self.trend,
            'period': self.period,
            'is_fitted': self.is_fitted
        }

    def __repr__(self) -> str:
        status = "fitted" if self.is_fitted else "not fitted"
        return f"StatefulSTLAtoms(seasonal={self.seasonal}, trend={self.trend}, {status})"


def demo_usage():
    """Demonstrate production usage with real data"""
    print("="*80)
    print("DEMO: Stateful STL Production Deployment")
    print("="*80)

    # Load sample data
    print("\n1. Loading data...")
    df = pd.read_csv('ml_feature_set/sample_data/resampled_binance_SOL-5m.csv')
    df['actual_ready_time'] = pd.to_datetime(df['date'])
    df = df.set_index('actual_ready_time')
    print(f"   Loaded {len(df)} rows")

    # Split into historical and streaming data
    historical_size = int(len(df) * 0.7)
    historical_data = df.iloc[:historical_size]
    streaming_data = df.iloc[historical_size:]

    print(f"\n2. Data split:")
    print(f"   Historical: {len(historical_data)} bars")
    print(f"   Streaming: {len(streaming_data)} bars")

    # Training phase
    print(f"\n3. Training phase (fit on historical)...")
    stl = StatefulSTLAtoms(seasonal=13, trend=31)
    stl.fit(historical_data)

    # Save model
    model_path = '/tmp/stl_sol_5m.pkl'
    stl.save(model_path)

    # Production phase
    print(f"\n4. Production phase (load and transform)...")
    stl_loaded = StatefulSTLAtoms.load(model_path)

    # Simulate streaming: process batches of new bars
    batch_size = 100
    print(f"\n5. Streaming simulation (batch size={batch_size})...")

    for i in range(0, len(streaming_data), batch_size):
        batch = streaming_data.iloc[i:i+batch_size]

        # Transform batch (fast!)
        features = stl_loaded.transform(batch)

        print(f"   Batch {i//batch_size + 1}: Transformed {len(batch)} bars")
        print(f"      Trend range: [{features['stl_trend'].min():.2f}, {features['stl_trend'].max():.2f}]")
        print(f"      Seasonal range: [{features['stl_seasonal'].min():.2f}, {features['stl_seasonal'].max():.2f}]")

        if i >= 300:  # Demo first 4 batches
            print(f"   ... (stopping demo after {i+batch_size} bars)")
            break

    print("\n" + "="*80)
    print("DEMO COMPLETE")
    print("="*80)
    print("\n✓ Stateful STL is production-ready")
    print("✓ Fit once on historical data")
    print("✓ Transform streaming data efficiently")
    print("✓ Save/load for deployment")


def benchmark_performance():
    """Benchmark stateful vs batch STL performance"""
    import time

    print("="*80)
    print("BENCHMARK: Stateful vs Batch STL")
    print("="*80)

    # Load data
    df = pd.read_csv('ml_feature_set/sample_data/resampled_binance_SOL-5m.csv')
    df['actual_ready_time'] = pd.to_datetime(df['date'])
    df = df.set_index('actual_ready_time')

    historical = df.iloc[:10000]
    new_bars = df.iloc[10000:10010]  # 10 new bars

    print(f"\nSetup:")
    print(f"  Historical data: {len(historical)} bars")
    print(f"  New data: {len(new_bars)} bars")

    # Method 1: Stateful (fit once, transform)
    print(f"\nMethod 1: Stateful STL")
    start = time.time()
    stl = StatefulSTLAtoms(seasonal=13, trend=31)
    stl.fit(historical)
    fit_time = time.time() - start

    start = time.time()
    features = stl.transform(new_bars)
    transform_time = time.time() - start

    print(f"  Fit time: {fit_time:.3f}s (one-time cost)")
    print(f"  Transform time: {transform_time:.3f}s ({len(new_bars)} bars)")
    print(f"  Per-bar transform: {transform_time/len(new_bars)*1000:.2f}ms")

    # Method 2: Batch (refit on full data)
    print(f"\nMethod 2: Batch STL (refit on all data)")
    full_data = pd.concat([historical, new_bars])

    start = time.time()
    batch_stl = STL(full_data['close'], period=13, seasonal=13, trend=31)
    batch_result = batch_stl.fit()
    batch_time = time.time() - start

    print(f"  Full refit time: {batch_time:.3f}s ({len(full_data)} bars)")
    print(f"  Per-bar cost: {batch_time/len(new_bars)*1000:.2f}ms")

    # Comparison
    print(f"\nSpeedup:")
    print(f"  Stateful transform is {batch_time/transform_time:.1f}x faster than batch refit")
    print(f"  ({transform_time*1000:.1f}ms vs {batch_time*1000:.1f}ms for {len(new_bars)} bars)")

    print("\n" + "="*80)


if __name__ == '__main__':
    # Run demo
    demo_usage()

    # Run benchmark
    print("\n")
    benchmark_performance()
