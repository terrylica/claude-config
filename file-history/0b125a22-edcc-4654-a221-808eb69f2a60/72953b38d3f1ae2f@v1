# Dukascopy Range Bar Construction - Design Q&A Log
**Status:** In Progress - Iterative Refinement  
**Date:** 2025-09-30  
**Purpose:** Record design decisions for polishing dukascopy-rangebar-construction.md

---

## Decision Log

### Q1: Volume Strategy (Critical Path) ✅ DECIDED

**Question:** Which volume handling approach should be canonical?

**Options Presented:**
- A) Simple liquidity sum for all instruments
- B) Tick count as volume for all instruments
- C) ⭐ Dual tracking (both metrics available)
- D) Instrument-specific (no dual tracking)

**Decision:** **C - Dual tracking with maximum Forex information retention**

**Implications:**
```rust
struct DukascopyRangeBar {
    pub base: RangeBar,
    pub spread_stats: SpreadStats {
        tick_count: u32,              // Always track
        total_bid_liquidity: FixedPoint,  // Always track
        total_ask_liquidity: FixedPoint,  // Always track
        avg_spread: FixedPoint,
        min_spread: FixedPoint,
        max_spread: FixedPoint,
    }
}
```

**Rationale:**
- Preserves both semantics (liquidity + activity)
- Downstream consumers can choose appropriate metric
- Maximizes information retention for Forex analysis

---

### Q2: Direction Inference Logic ✅ DECIDED

**Question:** How to handle `is_buyer_maker` field for synthetic trades?

**Research Findings:**
- Binance semantics: `is_buyer_maker=true` → buyer is passive (maker), seller aggressive (taker)
- Dukascopy provides **quote data only** (bid/ask/volumes), NOT trade data
- No actual trade direction available for ANY instrument (Forex, Crypto, all)

**Options Considered:**
- A) Infer from bid/ask volume asymmetry: `is_buyer_maker = bid_volume > ask_volume`
- B) Inverted logic
- C) Spread asymmetry heuristic
- D) ⭐ Explicit "unknown" - set to `None`

**Decision:** **D - Set `is_buyer_maker = None` for all Dukascopy data**

**Implications:**
```rust
AggTrade {
    // ... other fields
    is_buyer_maker: None,  // Explicit: direction unknown (quote data, not trades)
    is_best_match: None,   // N/A for Dukascopy
}
```

**Rationale:**
- Honest semantics: Dukascopy = quotes, not trades
- Forces conscious handling by downstream consumers
- Avoids false confidence in inferred/synthetic direction
- `Option<bool>` pattern already exists in struct

---

### Q3: RangeBar Structure Extension ✅ DECIDED

**Question:** How to return range bars with Dukascopy-specific information?

**Options Presented:**
- A) Return standard `RangeBar` (discard spread data)
- B) ⭐ Return wrapped structure `DukascopyRangeBar`
- C) Add fields directly to core `RangeBar`

**Decision:** **B - Wrapper pattern with `DukascopyRangeBar`**

**Implications:**
```rust
pub struct DukascopyRangeBar {
    pub base: RangeBar,           // Standard OHLCV + microstructure
    pub spread_stats: SpreadStats, // Dukascopy-specific metrics
}

pub struct SpreadStats {
    pub avg_spread: FixedPoint,
    pub min_spread: FixedPoint,
    pub max_spread: FixedPoint,
    pub tick_count: u32,
    pub total_bid_liquidity: FixedPoint,
    pub total_ask_liquidity: FixedPoint,
}
```

**Rationale:**
- Zero changes to core `RangeBar` struct (maintains "zero core changes" principle)
- Preserves all Dukascopy-specific information
- Consumers can unwrap `.base` for standard bar access
- Clean separation: aggTrades → RangeBar, Dukascopy → DukascopyRangeBar

---

## Open Questions (To Be Decided)

### Q4: Pending - Incomplete Bar Handling
- Where does partial bar state live?
- How to expose `get_incomplete_bar()` functionality?

### Q5: Pending - Error Handling Strategy
- Unknown instrument → panic vs Result::Err?
- Timestamp precision loss handling?

### Q6: Pending - Implementation Sequencing
- Strict phasing (Phase 1 → validate → Phase 2)?
- Parallel implementation?

### Q7: Pending - Moving Average Definition
- SMA, EMA, or volume-weighted?
- Alpha parameter for EMA?

### Q8: Pending - Zero-Volume Filtering Validation
- Empirical data check needed?
- Document assumption vs validate now?

### Q9: Pending - Documentation Structure
- Keep current flow?
- Reorganize to Quick Start → Deep Dive → Advanced?

---

## Summary of Decisions So Far

| Aspect | Decision | Status |
|--------|----------|--------|
| Volume semantics | Dual tracking (liquidity + tick_count) | ✅ |
| Direction inference | `is_buyer_maker = None` (explicit unknown) | ✅ |
| Structure | Wrapper pattern `DukascopyRangeBar { base, spread_stats }` | ✅ |
| Core algorithm changes | Zero (adapter pattern) | ✅ |

---

## Next Steps
- Continue Q&A iteration through remaining questions
- Update this log with each decision
- Use decisions to polish dukascopy-rangebar-construction.md
- User signals `LGTM` when ready for autonomous polishing

---

**Last Updated:** 2025-09-30 (Q1-Q3 complete)

### Q4: Incomplete Bar Handling ✅ DECIDED

**Question:** Where should partial bar state live?

**Context Discovery:**
- `RangeBarProcessor.get_incomplete_bar()` already exists (stubbed, returns `None`)
- `StreamingProcessor` already tries to use it for final bar at stream end
- Existing design intent: expose incomplete bars, just not yet implemented

**Options Considered:**
- A) Builder maintains shadow state (duplicate)
- B) ⭐ Implement `get_incomplete_bar()` in core processor
- C) No incomplete bar support

**Decision:** **B - Implement processor method (completes existing design)**

**Implications:**
```rust
// In RangeBarProcessor - IMPLEMENT existing stub
impl RangeBarProcessor {
    pub fn get_incomplete_bar(&self) -> Option<RangeBar> {
        self.current_bar_state.as_ref().map(|state| state.bar.clone())
    }
}

// In DukascopyRangeBarBuilder - wrap it with spread stats
impl DukascopyRangeBarBuilder {
    pub fn get_incomplete_bar(&self) -> Option<DukascopyRangeBar> {
        self.processor.get_incomplete_bar().map(|base| {
            DukascopyRangeBar {
                base,
                spread_stats: self.current_spread_stats.clone(),
            }
        })
    }
}
```

**Rationale:**
- Single source of truth (processor owns bar state)
- Benefits BOTH aggTrades and Dukascopy streaming
- Completes existing feature (not adding new one)
- Minimal implementation: expose existing internal state
- Streaming already depends on this - currently broken (returns None)

---


### Q5: Error Handling - Unknown Instrument ✅ DECIDED

**Question:** What happens when instrument isn't in config (unknown decimal factor)?

**Deep Dive Analysis:**
- Existing system already uses `Result<_, ProcessingError>` pattern
- `process_single_trade()` returns `Result<Option<RangeBar>, ProcessingError>`
- Integration is natural and clean

**Options Considered:**
- A) Panic/abort
- B) Return Result::Err (requires integration analysis)
- C) Use default decimal factor (silent corruption)
- D) Log warning + default

**Decision:** **B - Return Result with Approach 3 (Module-level error)**

**Implications:**
```rust
// New module-level error type
pub enum DukascopyError {
    Conversion(ConversionError),
    Processing(ProcessingError),
    Network(reqwest::Error),        // Future: HTTP fetching
    Decompression(std::io::Error),  // Future: LZMA errors
}

// Conversion-specific errors
pub enum ConversionError {
    UnsupportedInstrument { instrument: String },
    InvalidDecimalFactor { instrument: String },
}

// Automatic conversion with From trait
impl From<ProcessingError> for DukascopyError {
    fn from(e: ProcessingError) -> Self {
        DukascopyError::Processing(e)
    }
}

impl From<ConversionError> for DukascopyError {
    fn from(e: ConversionError) -> Self {
        DukascopyError::Conversion(e)
    }
}

// Builder signature
impl DukascopyRangeBarBuilder {
    pub fn process_tick(&mut self, tick: &DukascopyTick) 
        -> Result<Option<DukascopyRangeBar>, DukascopyError> 
    {
        let synthetic_trade = tick_to_synthetic_trade(tick, instrument)?; // Auto-converts
        let base_bar = self.processor.process_single_trade(synthetic_trade)?; // Auto-converts
        Ok(base_bar.map(|base| DukascopyRangeBar { base, spread_stats }))
    }
}
```

**Rationale:**
- Graceful error propagation (production-safe)
- Clean module boundaries (Dukascopy owns its error semantics)
- Future-proof (encompasses network, decompression errors)
- Automatic `?` operator conversion via `From` trait
- Clear error messages for debugging
- Prevents silent data corruption from wrong decimal factors

**Why Not Approach 2 (extend ProcessingError)?**
- Couples Dukascopy concerns to core error type
- Doesn't accommodate network/decompression errors naturally
- Less modular architecture

---


### Q6: Moving Average Definition ✅ DECIDED

**Question:** Which moving average type for spread tracking in real-time streaming?

**Research:** Studied talipp library (github.com/nardew/talipp)

**Key Insights:**
- Industry-standard EMA: `α = 2 / (period + 1)` not hardcoded
- O(1) incremental updates: only need previous EMA value
- Bootstrap pattern: SMA of first N values (optional)
- Explicit initialization with `Option<T>`

**Options Considered:**
- A) Simple Moving Average (needs tick count state)
- B) EMA with hardcoded α=0.1
- C) Volume-weighted average (complex)

**Decision:** **talipp-inspired EMA with Option 3 (No Bootstrap)**

**Implications:**
```rust
pub struct EMATracker {
    value: Option<FixedPoint>,  // None until initialized
    period: usize,               // e.g., 20 for short-term
    alpha: f64,                  // 2/(period+1)
    tick_count: u32,
}

impl EMATracker {
    pub fn new(period: usize) -> Self {
        Self {
            value: None,
            period,
            alpha: 2.0 / (period as f64 + 1.0),
            tick_count: 0,
        }
    }
    
    pub fn update(&mut self, new_value: FixedPoint) {
        self.tick_count += 1;
        
        match self.value {
            None if self.tick_count >= self.period as u32 => {
                self.value = Some(new_value);  // Initialize on Nth tick
            }
            Some(prev) => {
                // Incremental EMA (O(1))
                let alpha_fp = FixedPoint::from_f64(self.alpha);
                self.value = Some(
                    alpha_fp * new_value + (FixedPoint::ONE - alpha_fp) * prev
                );
            }
            _ => {} // Accumulating ticks
        }
    }
}

// Usage in SpreadStats:
pub struct SpreadStats {
    pub avg_spread: EMATracker,         // Period 20 EMA
    pub avg_bid_liquidity: EMATracker,
    pub avg_ask_liquidity: EMATracker,
    pub min_spread: FixedPoint,
    pub max_spread: FixedPoint,
    pub tick_count: u32,
    pub total_bid_liquidity: FixedPoint,
    pub total_ask_liquidity: FixedPoint,
}
```

**Rationale:**
- Industry-standard formula (matches Bloomberg/TradingView)
- O(1) performance (stateless after initialization)
- No buffer allocation (minimal memory)
- Explicit initialization with Option<FixedPoint>
- Reusable EMATracker for all metrics
- Period=20 recommended for intra-bar spread tracking

**User Memory Update:**
- Added talipp pattern to ~/.claude/CLAUDE.md for future reference
- Line: "Follow talipp pattern - O(1) incremental updates, α=2/(period+1), Option<T> initialization, stateless after bootstrap"

---

