# Claude Code User Memory

- Apply neutral, promotional-free language to generated docs/comments and new identifiers only; never alter user text; use SemVer 2.0.0 (init 1.0.0 if stable else 0.1.0); bump MAJOR for breaking, MINOR for additive, PATCH for fixes; update versions consistently across README/docstrings/metadata.

## Planning

- **Machine-Readable**: Define and maintain OpenAPI 3.1.1 spec for persistent planning files
- **Logical Dependencies**: Organize by capabilities, not time-based roadmapping - use Success Gates/Sluices for validation checkpoints
- **Dynamic Evolution**: Objectives and implementations evolve dynamically

## System Architecture & Environment

### Platform & Path Conventions
- **Target Platform**: Unix-like systems (macOS, Linux) - not Windows compatible
- **Standards**: `$HOME/.claude/` workspace, POSIX shells, use Unix conventions (`$HOME`, `$USER`) for portability

### Universal Tool Access & Working Directory Preservation
- **Hybrid Architecture**: `$HOME/.local/bin/` for executables, `$HOME/.claude/tools/` for configs - scripts use absolute paths and preserve working directory
- **PATH Standard**: Only `$HOME/.local/bin` in PATH, cross-platform consistency, avoid `cd` operations that change user context

### Current User Context
- Engineering lead responsible for features engineering for downstream seq-2-seq model consumption

## Development Environment & Tools

### Primary Toolchain
- **Python Stack**: `uv` (management), `uv run --active python -m` (execution), `maturin` (Rust integration), 3.12+ - **Avoid**: pip, conda, standalone execution
- **Rust Stack**: `cargo`, cross-platform compilation, `cargo nextest run`, `cargo deny check`, coexists with Python
- **Python Packages**: Prefer `httpx`, `platformdirs`, `orjson`, `ciso8601` over `requests`, `json`, `dateutil`, `arrow`, `maya`
- **Claude Code Tools**: `Read`, `LS`, `Glob`, `Grep` over MCP
- **Analysis**: `Semgrep`, `ast-grep`, `ShellCheck` - **GPU**: `tensorflow-metal`, `jax`, `torch`, `cupy`
- **PDF Processing**: `mupdf-tools` (`mutool draw -F html`) for born-digital PDFs with clean HTML/block grouping; Poppler `pdftohtml -xml` for exact coordinates or complex column layouts
- **Finance**: `backtesting.py` ONLY, `rangebar` crate - **Prohibited**: bt, vectorbt, mlfinlab, commercial libs
- **Technical Indicators**: Follow [talipp](https://github.com/nardew/talipp) incremental pattern - O(1) updates, no history buffers, stateless after initialization
- **Documentation**: ALL examples must use `uv run --active python -m` format, never standalone execution


### Technical Indicator Design Pattern (talipp-inspired)

**Reference**: https://github.com/nardew/talipp - Incremental technical analysis library

**Core Principles**:
- **O(1) Incremental Updates**: Each new value computed in constant time, independent of history size
- **No History Buffers**: Only maintain current state (e.g., previous EMA value), not entire value series
- **Stateless After Init**: Initialization may require bootstrap (e.g., SMA seed), then pure incremental updates
- **Industry-Standard Formulas**: Use canonical formulas (Bloomberg, TradingView compatibility)

**EMA Pattern (Standard)**:
```rust
// Industry formula: Œ± = 2 / (period + 1)
const PERIOD: usize = 20;  // Short-term: 20, Medium: 50, Long: 200
const ALPHA: f64 = 2.0 / (PERIOD as f64 + 1.0);  // ‚âà 0.095 for period=20

// Incremental update (O(1), no history needed)
new_ema = ALPHA * new_value + (1.0 - ALPHA) * previous_ema

// Use Option<T> for explicit initialization state
pub struct EMATracker {
    value: Option<FixedPoint>,  // None until initialized
    alpha: f64,
    period: usize,
}
```

**Key Benefits**:
- Efficient streaming (real-time market data processing)
- Minimal memory footprint (no Vec/deque accumulation)
- Composable (indicators can chain: EMA of EMA, etc.)
- Testable (deterministic state transitions)

**Anti-Patterns to Avoid**:
- ‚úó Storing full price history in Vec for recalculation
- ‚úó Hardcoded smoothing factors without period relationship
- ‚úó O(n) recalculation on each update
- ‚úó Implicit initialization (use `Option<T>` to make "not ready" explicit)

---

### Mandatory Rust Code Quality Enforcement (2025 Best Practices)
- **Zero Tolerance Policy**: All commits blocked unless passing `cargo fmt --check`, `cargo clippy -- -D warnings`, and `cargo test`
- **Enforcement**: Pre-commit hooks, VS Code auto-format, GitHub Actions validation
- **Setup**: `chmod +x .git/hooks/pre-commit && pre-commit install`

## Documentation Standards

### LLM-Optimized Documentation Architecture
- **Machine-Readable Priority**: OpenAPI 3.1.0 specs, JSON Schema, YAML specifications take precedence over human documentation
- **Integration Targets**: Cursor IDE, Claude Code CLI, AI coding assistants

### Claude Code Markdown Restrictions & README Policies
- **Markdown Files**: Global `~/.claude/` allowed, project `.claude/` prohibited (slash command conflicts)
- **README Policy**: Use `docs/README.md`, not root `README.md` - alternative naming for non-global docs

## Claude Code User Custom Extensions

### CNS (Conversation Notification System)
**Specification**: [`.claude/specifications/cns-conversation-notification-system.yaml`](.claude/specifications/cns-conversation-notification-system.yaml)

### GitHub Flavored Markdown Link Checker
**Specification**: [`.claude/specifications/gfm-link-checker.yaml`](.claude/specifications/gfm-link-checker.yaml)

### Pushover Integration
**Specification**: [`.claude/specifications/pushover-integration.yaml`](.claude/specifications/pushover-integration.yaml)

### PyPI Publishing Methods
**Specification**: [`.claude/specifications/pypi-publishing-methods.yaml`](.claude/specifications/pypi-publishing-methods.yaml)

### git-cliff Release Automation
**Templates**: `~/.claude/tools/git-cliff/templates/` (cliff.toml, cliff-release-notes.toml, cz.toml.template)

**AI Agent Workflow** (zero-config, Commitizen + git-cliff integration):
```bash
# Prerequisites: cargo, uvx, gh CLI
# Pre-flight: auto-install git-cliff, initialize configs from templates

command -v git-cliff >/dev/null || cargo install git-cliff
[ ! -f cliff.toml ] && cp ~/.claude/tools/git-cliff/templates/cliff.toml .
[ ! -f cliff-release-notes.toml ] && cp ~/.claude/tools/git-cliff/templates/cliff-release-notes.toml .
[ ! -f .cz.toml ] && cp ~/.claude/tools/git-cliff/templates/cz.toml.template .cz.toml

# 1) Commit: synthesize conventional commit from staged diff (AI-driven)
uvx --from commitizen cz check --message "$MSG"
git commit -m "$MSG"

# 2) Version bump + changelog (git-cliff replaces commitizen changelog)
uvx --from commitizen cz bump --yes
git-cliff --config cliff.toml --output CHANGELOG.md
git-cliff --config cliff-release-notes.toml --latest --output RELEASE_NOTES.md
git add CHANGELOG.md RELEASE_NOTES.md && git commit --amend --no-edit

# 3) Publish commits and tag
git push --follow-tags

# 4) Surface CI and monitor
gh run view --web

# 5) GitHub Release (auto-generated from git-cliff)
TAG="v$(grep '^version = ' .cz.toml | cut -d'"' -f2)"
gh release create "$TAG" --verify-tag --title "$(basename $(pwd)) $TAG" -F RELEASE_NOTES.md

# 6) Telemetry: milestone commit SHA and tag, surface all URLs
echo "üì¶ Release: https://github.com/$(gh repo view --json nameWithOwner -q .nameWithOwner)/releases/tag/$TAG"
echo "üîó CI Run: $(gh run list --limit 1 --json url --jq '.[0].url')"
echo "üìù Commit: $(git rev-parse HEAD)"
```

**Notes**:
- Commitizen handles SemVer validation and version bumping
- git-cliff generates CHANGELOG.md (detailed) and RELEASE_NOTES.md (user-facing)
- Use Git LFS for large binaries if needed

## Credential Management & Security

**Credential Management**: Doppler CLI (`doppler run -- <command>`) for zero-config credential injection
**Specification**: [`.claude/specifications/doppler-integration.yaml`](.claude/specifications/doppler-integration.yaml)

